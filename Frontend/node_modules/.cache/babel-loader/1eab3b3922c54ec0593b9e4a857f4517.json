{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = sequenceOfValidator;\n\nvar _propTypes = require(\"prop-types\");\n\nvar _and = _interopRequireDefault(require(\"./and\"));\n\nvar _between = _interopRequireDefault(require(\"./between\"));\n\nvar _nonNegativeInteger = _interopRequireDefault(require(\"./nonNegativeInteger\"));\n\nvar _object = _interopRequireDefault(require(\"./object\"));\n\nvar _withShape = _interopRequireDefault(require(\"./withShape\"));\n\nvar _typeOf = _interopRequireDefault(require(\"./helpers/typeOf\"));\n\nvar _wrapValidator = _interopRequireDefault(require(\"./helpers/wrapValidator\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar minValidator = _nonNegativeInteger[\"default\"];\nvar maxValidator = (0, _and[\"default\"])([_nonNegativeInteger[\"default\"], (0, _between[\"default\"])({\n  gte: 1\n})]);\n\nfunction validateRange(min, max) {\n  if (typeof max !== 'number' || typeof min !== 'number') {\n    return null; // no additional checking needed unless both are present\n  }\n\n  if (min <= max) {\n    return null;\n  }\n\n  return new RangeError('min must be less than or equal to max');\n}\n\nvar specifierShape = {\n  validator: function validator(props, propName) {\n    var propValue = props[propName];\n\n    if (typeof propValue !== 'function') {\n      return new TypeError('\"validator\" must be a propType validator function');\n    }\n\n    return null;\n  },\n  min: function min(props, propName) {\n    return minValidator(props, propName) || validateRange(props.min, props.max);\n  },\n  max: function max(props, propName) {\n    return maxValidator(props, propName) || validateRange(props.min, props.max);\n  }\n};\n\nfunction getMinMax(_ref) {\n  var min = _ref.min,\n      max = _ref.max;\n  var minimum;\n  var maximum;\n\n  if (typeof min !== 'number' && typeof max !== 'number') {\n    // neither provided, default to \"1\"\n    minimum = 1;\n    maximum = 1;\n  } else {\n    minimum = typeof min === 'number' ? min : 1;\n    maximum = typeof max === 'number' ? max : Infinity;\n  }\n\n  return {\n    minimum: minimum,\n    maximum: maximum\n  };\n}\n\nfunction chunkByType(items) {\n  var chunk = [];\n  var lastType;\n  return items.reduce(function (chunks, item) {\n    var itemType = (0, _typeOf[\"default\"])(item);\n\n    if (!lastType || itemType === lastType) {\n      chunk.push(item);\n    } else {\n      chunks.push(chunk);\n      chunk = [item];\n    }\n\n    lastType = itemType;\n    return chunks;\n  }, []).concat(chunk.length > 0 ? [chunk] : []);\n}\n\nfunction validateChunks(specifiers, props, propName, componentName) {\n  var items = props[propName];\n  var chunks = chunkByType(items);\n\n  for (var _len = arguments.length, rest = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {\n    rest[_key - 4] = arguments[_key];\n  }\n\n  for (var i = 0; i < specifiers.length; i += 1) {\n    var _specifiers$i = specifiers[i],\n        validator = _specifiers$i.validator,\n        min = _specifiers$i.min,\n        max = _specifiers$i.max;\n\n    var _getMinMax = getMinMax({\n      min: min,\n      max: max\n    }),\n        minimum = _getMinMax.minimum,\n        maximum = _getMinMax.maximum;\n\n    if (chunks.length === 0 && minimum === 0) {\n      // no chunks left, but this specifier does not require any items\n      continue; // eslint-disable-line no-continue\n    }\n\n    var arrayOfValidator = (0, _propTypes.arrayOf)(validator).isRequired;\n    var chunk = chunks.shift(); // extract the next chunk to test\n\n    var chunkError = arrayOfValidator.apply(void 0, [_objectSpread(_objectSpread({}, props), {}, _defineProperty({}, propName, chunk)), propName, componentName].concat(rest));\n\n    if (chunkError) {\n      // this chunk is invalid\n      if (minimum === 0) {\n        // but, specifier has a min of 0 and can be skipped\n        chunks.unshift(chunk); // put the chunk back, for the next iteration\n\n        continue; // eslint-disable-line no-continue\n      }\n\n      return chunkError;\n    } // chunk is valid!\n\n\n    if (chunk.length < minimum) {\n      return new RangeError(\"\".concat(componentName, \": specifier index \").concat(i, \" requires a minimum of \").concat(min, \" items, but only has \").concat(chunk.length, \".\"));\n    }\n\n    if (chunk.length > maximum) {\n      return new RangeError(\"\".concat(componentName, \": specifier index \").concat(i, \" requires a maximum of \").concat(max, \" items, but has \").concat(chunk.length, \".\"));\n    }\n  }\n\n  if (chunks.length > 0) {\n    return new TypeError(\"\".concat(componentName, \": after all \").concat(specifiers.length, \" specifiers matched, \").concat(chunks.length, \" types of items were remaining.\"));\n  }\n\n  return null;\n}\n\nvar specifierValidator = (0, _withShape[\"default\"])((0, _object[\"default\"])(), specifierShape).isRequired;\n\nfunction sequenceOfValidator() {\n  for (var _len2 = arguments.length, specifiers = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    specifiers[_key2] = arguments[_key2];\n  }\n\n  if (specifiers.length === 0) {\n    throw new RangeError('sequenceOf: at least one specifier is required');\n  }\n\n  var errors = specifiers.map(function (specifier, i) {\n    return specifierValidator({\n      specifier: specifier\n    }, 'specifier', 'sequenceOf specifier', \"suequenceOf specifier, index \".concat(i), \"specifier, index \".concat(i));\n  });\n\n  if (errors.some(Boolean)) {\n    throw new TypeError(\"\\n      sequenceOf: all specifiers must match the appropriate shape.\\n\\n      Errors:\\n        \".concat(errors.map(function (e, i) {\n      return \" - Argument index \".concat(i, \": \").concat(e.message);\n    }).join(',\\n        '), \"\\n    \"));\n  }\n\n  var validator = function sequenceOf(props, propName) {\n    var propValue = props[propName];\n\n    if (propValue == null) {\n      return null;\n    }\n\n    for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      rest[_key3 - 2] = arguments[_key3];\n    }\n\n    var error = _propTypes.array.apply(void 0, [props, propName].concat(rest));\n\n    if (error) {\n      return error;\n    }\n\n    return validateChunks.apply(void 0, [specifiers, props, propName].concat(rest));\n  };\n\n  validator.isRequired = function sequenceOfRequired(props, propName, componentName) {\n    for (var _len4 = arguments.length, rest = new Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {\n      rest[_key4 - 3] = arguments[_key4];\n    }\n\n    var error = _propTypes.array.isRequired.apply(_propTypes.array, [props, propName, componentName].concat(rest));\n\n    if (error) {\n      return error;\n    }\n\n    return validateChunks.apply(void 0, [specifiers, props, propName, componentName].concat(rest));\n  };\n\n  return (0, _wrapValidator[\"default\"])(validator, 'sequenceOf', specifiers);\n}","map":{"version":3,"sources":["../src/sequenceOf.js"],"names":["minValidator","nonNegativeInteger","maxValidator","gte","min","specifierShape","validator","propValue","props","validateRange","max","minimum","maximum","chunk","itemType","chunks","lastType","rest","items","chunkByType","i","specifiers","getMinMax","arrayOfValidator","chunkError","specifierValidator","errors","specifier","e","error","array","validateChunks"],"mappings":"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","sourcesContent":["import { array, arrayOf } from 'prop-types';\n\nimport and from './and';\nimport between from './between';\nimport nonNegativeInteger from './nonNegativeInteger';\nimport object from './object';\nimport withShape from './withShape';\nimport typeOf from './helpers/typeOf';\nimport wrapValidator from './helpers/wrapValidator';\n\nconst minValidator = nonNegativeInteger;\nconst maxValidator = and([nonNegativeInteger, between({ gte: 1 })]);\n\nfunction validateRange(min, max) {\n  if (typeof max !== 'number' || typeof min !== 'number') {\n    return null; // no additional checking needed unless both are present\n  }\n\n  if (min <= max) {\n    return null;\n  }\n  return new RangeError('min must be less than or equal to max');\n}\n\nconst specifierShape = {\n  validator(props, propName) {\n    const { [propName]: propValue } = props;\n    if (typeof propValue !== 'function') {\n      return new TypeError('\"validator\" must be a propType validator function');\n    }\n    return null;\n  },\n\n  min(props, propName) {\n    return minValidator(props, propName) || validateRange(props.min, props.max);\n  },\n\n  max(props, propName) {\n    return maxValidator(props, propName) || validateRange(props.min, props.max);\n  },\n};\n\nfunction getMinMax({ min, max }) {\n  let minimum;\n  let maximum;\n  if (typeof min !== 'number' && typeof max !== 'number') {\n    // neither provided, default to \"1\"\n    minimum = 1;\n    maximum = 1;\n  } else {\n    minimum = typeof min === 'number' ? min : 1;\n    maximum = typeof max === 'number' ? max : Infinity;\n  }\n  return { minimum, maximum };\n}\n\nfunction chunkByType(items) {\n  let chunk = [];\n  let lastType;\n  return items.reduce((chunks, item) => {\n    const itemType = typeOf(item);\n    if (!lastType || itemType === lastType) {\n      chunk.push(item);\n    } else {\n      chunks.push(chunk);\n      chunk = [item];\n    }\n    lastType = itemType;\n    return chunks;\n  }, []).concat(chunk.length > 0 ? [chunk] : []);\n}\n\nfunction validateChunks(specifiers, props, propName, componentName, ...rest) {\n  const { [propName]: items } = props;\n  const chunks = chunkByType(items);\n\n  for (let i = 0; i < specifiers.length; i += 1) {\n    const { validator, min, max } = specifiers[i];\n\n    const { minimum, maximum } = getMinMax({ min, max });\n\n    if (chunks.length === 0 && minimum === 0) {\n      // no chunks left, but this specifier does not require any items\n      continue; // eslint-disable-line no-continue\n    }\n\n    const arrayOfValidator = arrayOf(validator).isRequired;\n\n    const chunk = chunks.shift(); // extract the next chunk to test\n\n    const chunkError = arrayOfValidator(\n      { ...props, [propName]: chunk },\n      propName,\n      componentName,\n      ...rest,\n    );\n\n    if (chunkError) { // this chunk is invalid\n      if (minimum === 0) { // but, specifier has a min of 0 and can be skipped\n        chunks.unshift(chunk); // put the chunk back, for the next iteration\n        continue; // eslint-disable-line no-continue\n      }\n      return chunkError;\n    }\n\n    // chunk is valid!\n\n    if (chunk.length < minimum) {\n      return new RangeError(`${componentName}: specifier index ${i} requires a minimum of ${min} items, but only has ${chunk.length}.`);\n    }\n\n    if (chunk.length > maximum) {\n      return new RangeError(`${componentName}: specifier index ${i} requires a maximum of ${max} items, but has ${chunk.length}.`);\n    }\n  }\n\n  if (chunks.length > 0) {\n    return new TypeError(`${componentName}: after all ${specifiers.length} specifiers matched, ${chunks.length} types of items were remaining.`);\n  }\n\n  return null;\n}\n\nconst specifierValidator = withShape(object(), specifierShape).isRequired;\n\nexport default function sequenceOfValidator(...specifiers) {\n  if (specifiers.length === 0) {\n    throw new RangeError('sequenceOf: at least one specifier is required');\n  }\n\n  const errors = specifiers.map((specifier, i) => specifierValidator(\n    { specifier },\n    'specifier',\n    'sequenceOf specifier',\n    `suequenceOf specifier, index ${i}`,\n    `specifier, index ${i}`,\n  ));\n  if (errors.some(Boolean)) {\n    throw new TypeError(`\n      sequenceOf: all specifiers must match the appropriate shape.\n\n      Errors:\n        ${errors.map((e, i) => ` - Argument index ${i}: ${e.message}`).join(',\\n        ')}\n    `);\n  }\n\n  const validator = function sequenceOf(props, propName, ...rest) {\n    const { [propName]: propValue } = props;\n\n    if (propValue == null) {\n      return null;\n    }\n\n    const error = array(props, propName, ...rest);\n    if (error) {\n      return error;\n    }\n\n    return validateChunks(specifiers, props, propName, ...rest);\n  };\n\n  validator.isRequired = function sequenceOfRequired(props, propName, componentName, ...rest) {\n    const error = array.isRequired(props, propName, componentName, ...rest);\n    if (error) {\n      return error;\n    }\n\n    return validateChunks(specifiers, props, propName, componentName, ...rest);\n  };\n\n  return wrapValidator(validator, 'sequenceOf', specifiers);\n}\n"]},"metadata":{},"sourceType":"script"}