{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _arrayPrototype = _interopRequireDefault(require(\"array.prototype.find\"));\n\nvar _getComponentName = _interopRequireDefault(require(\"./helpers/getComponentName\"));\n\nvar _renderableChildren = _interopRequireDefault(require(\"./helpers/renderableChildren\"));\n\nvar _wrapValidator = _interopRequireDefault(require(\"./helpers/wrapValidator\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction onlyTypes(types, children, componentName) {\n  if (!children.every(function (child) {\n    return child && (0, _arrayPrototype[\"default\"])(types, function (Type) {\n      return Type === '*' || child.type === Type;\n    });\n  })) {\n    var typeNames = types.map(_getComponentName[\"default\"]).join(', or ');\n    return new TypeError(\"`\".concat(componentName, \"` only accepts children of type \").concat(typeNames));\n  }\n\n  return null;\n}\n\nfunction isRequired(types, children, componentName) {\n  if (children.length === 0) {\n    var typeNames = types.map(_getComponentName[\"default\"]).join(', or ');\n    return new TypeError(\"`\".concat(componentName, \"` requires at least one node of type \").concat(typeNames));\n  }\n\n  return null;\n}\n\nfunction childrenOfType() {\n  for (var _len = arguments.length, types = new Array(_len), _key = 0; _key < _len; _key++) {\n    types[_key] = arguments[_key];\n  }\n\n  if (types.length < 1) {\n    throw new TypeError('childrenOfType: at least 1 type is required');\n  }\n\n  function validator(props, propName, componentName) {\n    return onlyTypes(types, (0, _renderableChildren[\"default\"])(props[propName]), componentName);\n  }\n\n  validator.isRequired = function (props, propName, componentName) {\n    var children = (0, _renderableChildren[\"default\"])(props[propName]);\n    return isRequired(types, children, componentName) || onlyTypes(types, children, componentName);\n  };\n\n  return (0, _wrapValidator[\"default\"])(validator, 'childrenOfType', types);\n}\n\nvar _default = childrenOfType;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["../src/childrenOfType.js"],"names":["child","Type","typeNames","types","getComponentName","children","onlyTypes","props","validator","isRequired","childrenOfType"],"mappings":";;;;;;;AAAA,IAAA,eAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,sBAAA,CAAA,CAAA;;AAEA,IAAA,iBAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,4BAAA,CAAA,CAAA;;AACA,IAAA,mBAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,8BAAA,CAAA,CAAA;;AACA,IAAA,cAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,yBAAA,CAAA,CAAA;;;;;;;;AAEA,SAAA,SAAA,CAAA,KAAA,EAAA,QAAA,EAAA,aAAA,EAAmD;AACjD,MAAI,CAAC,QAAQ,CAAR,KAAA,CAAe,UAAA,KAAA,EAAA;AAAA,WAAWA,KAAK,IAAI,CAAA,GAAA,eAAA,CAAA,SAAA,CAAA,EAAA,KAAA,EAAY,UAAA,IAAA,EAAA;AAAA,aAAUC,IAAI,KAAJA,GAAAA,IAAgBD,KAAK,CAALA,IAAAA,KAA1B,IAAA;AAAhC,KAAoB,CAApB;AAApB,GAAK,CAAL,EAAqG;AACnG,QAAME,SAAS,GAAGC,KAAK,CAALA,GAAAA,CAAUC,iBAAAA,CAAVD,SAAUC,CAAVD,EAAAA,IAAAA,CAAlB,OAAkBA,CAAlB;AACA,WAAO,IAAA,SAAA,CAAA,IAAA,MAAA,CAAA,aAAA,EAAA,kCAAA,EAAA,MAAA,CAAP,SAAO,CAAA,CAAP;AAGD;;AACD,SAAA,IAAA;AACD;;AAED,SAAA,UAAA,CAAA,KAAA,EAAA,QAAA,EAAA,aAAA,EAAoD;AAClD,MAAIE,QAAQ,CAARA,MAAAA,KAAJ,CAAA,EAA2B;AACzB,QAAMH,SAAS,GAAGC,KAAK,CAALA,GAAAA,CAAUC,iBAAAA,CAAVD,SAAUC,CAAVD,EAAAA,IAAAA,CAAlB,OAAkBA,CAAlB;AACA,WAAO,IAAA,SAAA,CAAA,IAAA,MAAA,CAAA,aAAA,EAAA,uCAAA,EAAA,MAAA,CAAP,SAAO,CAAA,CAAP;AACD;;AACD,SAAA,IAAA;AACD;;AAED,SAAA,cAAA,GAAkC;AAAA,OAAA,IAAA,IAAA,GAAA,SAAA,CAAA,MAAA,EAAPA,KAAO,GAAA,IAAA,KAAA,CAAA,IAAA,CAAA,EAAA,IAAA,GAAA,CAAA,EAAA,IAAA,GAAA,IAAA,EAAA,IAAA,EAAA,EAAA;AAAPA,IAAAA,KAAO,CAAA,IAAA,CAAPA,GAAO,SAAA,CAAA,IAAA,CAAPA;AAAO;;AAChC,MAAIA,KAAK,CAALA,MAAAA,GAAJ,CAAA,EAAsB;AACpB,UAAM,IAAA,SAAA,CAAN,6CAAM,CAAN;AACD;;AAED,WAAA,SAAA,CAAA,KAAA,EAAA,QAAA,EAAA,aAAA,EAAmD;AACjD,WAAOG,SAAS,CAAA,KAAA,EAAQ,CAAA,GAAA,mBAAA,CAAA,SAAA,CAAA,EAAmBC,KAAK,CAAhC,QAAgC,CAAxB,CAAR,EAAhB,aAAgB,CAAhB;AACD;;AAEDC,EAAAA,SAAS,CAATA,UAAAA,GAAuB,UAAA,KAAA,EAAA,QAAA,EAAA,aAAA,EAAoC;AACzD,QAAMH,QAAQ,GAAG,CAAA,GAAA,mBAAA,CAAA,SAAA,CAAA,EAAmBE,KAAK,CAAzC,QAAyC,CAAxB,CAAjB;AACA,WAAOE,UAAU,CAAA,KAAA,EAAA,QAAA,EAAVA,aAAU,CAAVA,IAA8CH,SAAS,CAAA,KAAA,EAAA,QAAA,EAA9D,aAA8D,CAA9D;AAFFE,GAAAA;;AAKA,SAAO,CAAA,GAAA,cAAA,CAAA,SAAA,CAAA,EAAA,SAAA,EAAA,gBAAA,EAAP,KAAO,CAAP;AACD;;eAEcE,c","sourcesContent":["import find from 'array.prototype.find';\n\nimport getComponentName from './helpers/getComponentName';\nimport renderableChildren from './helpers/renderableChildren';\nimport wrapValidator from './helpers/wrapValidator';\n\nfunction onlyTypes(types, children, componentName) {\n  if (!children.every((child) => child && find(types, (Type) => Type === '*' || child.type === Type))) {\n    const typeNames = types.map(getComponentName).join(', or ');\n    return new TypeError(\n      `\\`${componentName}\\` only accepts children of type ${typeNames}`,\n    );\n  }\n  return null;\n}\n\nfunction isRequired(types, children, componentName) {\n  if (children.length === 0) {\n    const typeNames = types.map(getComponentName).join(', or ');\n    return new TypeError(`\\`${componentName}\\` requires at least one node of type ${typeNames}`);\n  }\n  return null;\n}\n\nfunction childrenOfType(...types) {\n  if (types.length < 1) {\n    throw new TypeError('childrenOfType: at least 1 type is required');\n  }\n\n  function validator(props, propName, componentName) {\n    return onlyTypes(types, renderableChildren(props[propName]), componentName);\n  }\n\n  validator.isRequired = (props, propName, componentName) => {\n    const children = renderableChildren(props[propName]);\n    return isRequired(types, children, componentName) || onlyTypes(types, children, componentName);\n  };\n\n  return wrapValidator(validator, 'childrenOfType', types);\n}\n\nexport default childrenOfType;\n"]},"metadata":{},"sourceType":"script"}