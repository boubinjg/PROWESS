{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = elementTypeValidator;\n\nvar _propTypes = require(\"prop-types\");\n\nvar _reactIs = require(\"react-is\");\n\nvar _and = _interopRequireDefault(require(\"./and\"));\n\nvar _getComponentName = _interopRequireDefault(require(\"./helpers/getComponentName\"));\n\nvar _wrapValidator = _interopRequireDefault(require(\"./helpers/wrapValidator\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction getTypeName(Type) {\n  if (typeof Type === 'string') {\n    return Type;\n  }\n\n  var type = (0, _getComponentName[\"default\"])(Type);\n  /* istanbul ignore next */\n  // in environments where functions do not have names\n\n  return type || 'Anonymous Component';\n}\n\nfunction validateElementType(Type, props, propName, componentName) {\n  var type = props[propName].type;\n\n  if (type === Type) {\n    return null;\n  }\n\n  return new TypeError(\"\".concat(componentName, \".\").concat(propName, \" must be a React element of type \").concat(getTypeName(Type)));\n}\n\nfunction elementTypeValidator(Type) {\n  if (Type === '*') {\n    return (0, _wrapValidator[\"default\"])(_propTypes.element, 'elementType(*)', Type);\n  }\n\n  if (!(0, _reactIs.isValidElementType)(Type)) {\n    throw new TypeError(\"Type must be a React Component, an HTML element tag name, or \\\"*\\\". Got an \".concat(_typeof(Type)));\n  }\n\n  function elementType(props, propName, componentName) {\n    if (props[propName] == null) {\n      return null;\n    }\n\n    for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      rest[_key - 3] = arguments[_key];\n    }\n\n    return validateElementType.apply(void 0, [Type, props, propName, componentName].concat(rest));\n  }\n\n  elementType.isRequired = elementType; // covered by and + element\n\n  var typeName = getTypeName(Type);\n  var validatorName = \"elementType(\".concat(typeName, \")\");\n  return (0, _wrapValidator[\"default\"])((0, _and[\"default\"])([_propTypes.element, elementType], validatorName), validatorName, Type);\n}","map":{"version":3,"sources":["../src/elementType.js"],"names":["type","props","getTypeName","Type","element","rest","validateElementType","elementType","typeName","validatorName"],"mappings":";;;;;;;AAAA,IAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAEA,IAAA,IAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,IAAA,iBAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,4BAAA,CAAA,CAAA;;AACA,IAAA,cAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,yBAAA,CAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;AAEA,SAAA,WAAA,CAAA,IAAA,EAA2B;AACzB,MAAI,OAAA,IAAA,KAAJ,QAAA,EAA8B;AAC5B,WAAA,IAAA;AACD;;AACD,MAAMA,IAAI,GAAG,CAAA,GAAA,iBAAA,CAAA,SAAA,CAAA,EAAb,IAAa,CAAb;AAEA;AAA2B;;AAC3B,SAAOA,IAAI,IAAX,qBAAA;AACD;;AAED,SAAA,mBAAA,CAAA,IAAA,EAAA,KAAA,EAAA,QAAA,EAAA,aAAA,EAAmE;AAAA,MACzDA,IADyD,GAChDC,KAAK,CAD2C,QAC3C,CAALA,CADgD,IAAA;;AAGjE,MAAID,IAAI,KAAR,IAAA,EAAmB;AACjB,WAAA,IAAA;AACD;;AAED,SAAO,IAAA,SAAA,CAAA,GAAA,MAAA,CAAA,aAAA,EAAA,GAAA,EAAA,MAAA,CAAA,QAAA,EAAA,mCAAA,EAAA,MAAA,CAA8EE,WAAW,CAAhG,IAAgG,CAAzF,CAAA,CAAP;AACD;;AAEc,SAAA,oBAAA,CAAA,IAAA,EAAoC;AACjD,MAAIC,IAAI,KAAR,GAAA,EAAkB;AAChB,WAAO,CAAA,GAAA,cAAA,CAAA,SAAA,CAAA,EAAcC,UAAAA,CAAd,OAAA,EAAA,gBAAA,EAAP,IAAO,CAAP;AACD;;AAED,MAAI,CAAC,CAAA,GAAA,QAAA,CAAA,kBAAA,EAAL,IAAK,CAAL,EAA+B;AAC7B,UAAM,IAAA,SAAA,CAAA,8EAAA,MAAA,CAAA,OAAA,CAAN,IAAM,CAAA,CAAA,CAAN;AACD;;AAED,WAAA,WAAA,CAAA,KAAA,EAAA,QAAA,EAAA,aAAA,EAA8D;AAC5D,QAAIH,KAAK,CAALA,QAAK,CAALA,IAAJ,IAAA,EAA6B;AAC3B,aAAA,IAAA;AACD;;AAH2D,SAAA,IAAA,IAAA,GAAA,SAAA,CAAA,MAAA,EAANI,IAAM,GAAA,IAAA,KAAA,CAAA,IAAA,GAAA,CAAA,GAAA,IAAA,GAAA,CAAA,GAAA,CAAA,CAAA,EAAA,IAAA,GAAA,CAAA,EAAA,IAAA,GAAA,IAAA,EAAA,IAAA,EAAA,EAAA;AAANA,MAAAA,IAAM,CAAA,IAAA,GAAA,CAAA,CAANA,GAAM,SAAA,CAAA,IAAA,CAANA;AAAM;;AAI5D,WAAOC,mBAAmB,CAAnBA,KAAAA,CAAAA,KAAAA,CAAAA,EAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,QAAAA,EAAAA,aAAAA,EAAAA,MAAAA,CAAP,IAAOA,CAAAA,CAAP;AACD;;AACDC,EAAAA,WAAW,CAAXA,UAAAA,GAfiD,WAejDA,CAfiD,CAeX;;AAEtC,MAAMC,QAAQ,GAAGN,WAAW,CAA5B,IAA4B,CAA5B;AACA,MAAMO,aAAa,GAAA,eAAA,MAAA,CAAA,QAAA,EAAnB,GAAmB,CAAnB;AACA,SAAO,CAAA,GAAA,cAAA,CAAA,SAAA,CAAA,EAAc,CAAA,GAAA,IAAA,CAAA,SAAA,CAAA,EAAI,CAACL,UAAAA,CAAD,OAAA,EAAJ,WAAI,CAAJ,EAAd,aAAc,CAAd,EAAA,aAAA,EAAP,IAAO,CAAP;AACD","sourcesContent":["import { element } from 'prop-types';\nimport { isValidElementType } from 'react-is';\n\nimport and from './and';\nimport getComponentName from './helpers/getComponentName';\nimport wrapValidator from './helpers/wrapValidator';\n\nfunction getTypeName(Type) {\n  if (typeof Type === 'string') {\n    return Type;\n  }\n  const type = getComponentName(Type);\n\n  /* istanbul ignore next */ // in environments where functions do not have names\n  return type || 'Anonymous Component';\n}\n\nfunction validateElementType(Type, props, propName, componentName) {\n  const { type } = props[propName];\n\n  if (type === Type) {\n    return null;\n  }\n\n  return new TypeError(`${componentName}.${propName} must be a React element of type ${getTypeName(Type)}`);\n}\n\nexport default function elementTypeValidator(Type) {\n  if (Type === '*') {\n    return wrapValidator(element, 'elementType(*)', Type);\n  }\n\n  if (!isValidElementType(Type)) {\n    throw new TypeError(`Type must be a React Component, an HTML element tag name, or \"*\". Got an ${typeof Type}`);\n  }\n\n  function elementType(props, propName, componentName, ...rest) {\n    if (props[propName] == null) {\n      return null;\n    }\n    return validateElementType(Type, props, propName, componentName, ...rest);\n  }\n  elementType.isRequired = elementType; // covered by and + element\n\n  const typeName = getTypeName(Type);\n  const validatorName = `elementType(${typeName})`;\n  return wrapValidator(and([element, elementType], validatorName), validatorName, Type);\n}\n"]},"metadata":{},"sourceType":"script"}