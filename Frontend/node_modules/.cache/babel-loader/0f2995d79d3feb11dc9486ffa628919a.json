{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = componentWithName;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _isRegex = _interopRequireDefault(require(\"is-regex\"));\n\nvar _arrayPrototype = _interopRequireDefault(require(\"array.prototype.find\"));\n\nvar _getComponentName = _interopRequireDefault(require(\"./helpers/getComponentName\"));\n\nvar _wrapValidator = _interopRequireDefault(require(\"./helpers/wrapValidator\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction stripHOCs(fullName, namesOfHOCsToStrip) {\n  var innerName = fullName;\n\n  while (/\\([^()]*\\)/g.test(innerName)) {\n    var HOC = innerName;\n    var previousHOC = void 0;\n\n    do {\n      previousHOC = HOC;\n      HOC = previousHOC.replace(/\\([^()]*\\)/g, '');\n    } while (previousHOC !== HOC);\n\n    if (namesOfHOCsToStrip.indexOf(HOC) === -1) {\n      return innerName;\n    }\n\n    innerName = innerName.replace(RegExp(\"^\".concat(HOC, \"\\\\(|\\\\)$\"), 'g'), '');\n  }\n\n  return innerName;\n}\n\nfunction hasName(name, namesOfHOCsToStrip, propValue, propName, componentName) {\n  for (var _len = arguments.length, rest = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {\n    rest[_key - 5] = arguments[_key];\n  }\n\n  if (Array.isArray(propValue)) {\n    return (0, _arrayPrototype[\"default\"])(propValue.map(function (item) {\n      return hasName.apply(void 0, [name, namesOfHOCsToStrip, item, propName, componentName].concat(rest));\n    }), Boolean) || null;\n  }\n\n  if (! /*#__PURE__*/_react[\"default\"].isValidElement(propValue)) {\n    return new TypeError(\"\".concat(componentName, \".\").concat(propName, \" is not a valid React element\"));\n  }\n\n  var type = propValue.type;\n  var componentNameFromType = (0, _getComponentName[\"default\"])(type);\n  var innerComponentName = namesOfHOCsToStrip.length > 0 ? stripHOCs(componentNameFromType, namesOfHOCsToStrip) : componentNameFromType;\n\n  if ((0, _isRegex[\"default\"])(name) && !name.test(innerComponentName)) {\n    return new TypeError(\"`\".concat(componentName, \".\").concat(propName, \"` only accepts components matching the regular expression \").concat(name));\n  }\n\n  if (!(0, _isRegex[\"default\"])(name) && innerComponentName !== name) {\n    return new TypeError(\"`\".concat(componentName, \".\").concat(propName, \"` only accepts components named \").concat(name, \", got \").concat(innerComponentName));\n  }\n\n  return null;\n}\n\nfunction componentWithName(name) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof name !== 'string' && !(0, _isRegex[\"default\"])(name)) {\n    throw new TypeError('name must be a string or a regex');\n  }\n\n  var passedOptions = Object.keys(options);\n\n  if (passedOptions.length > 1 || passedOptions.length === 1 && passedOptions[0] !== 'stripHOCs') {\n    throw new TypeError(\"The only options supported are: \\u201CstripHOCs\\u201D, got: \\u201C\".concat(passedOptions.join('”, “'), \"\\u201D\"));\n  }\n\n  var _options$stripHOCs = options.stripHOCs,\n      namesOfHOCsToStrip = _options$stripHOCs === void 0 ? [] : _options$stripHOCs;\n  var allHOCNamesAreValid = namesOfHOCsToStrip.every(function (x) {\n    if (typeof x !== 'string' || /[()]/g.test(x)) {\n      return false;\n    }\n\n    return /^(?:[a-z][a-zA-Z0-9]+|[A-Z][a-z][a-zA-Z0-9]+)$/.test(x);\n  });\n\n  if (!allHOCNamesAreValid) {\n    throw new TypeError('every provided HOC name must be a string with no parens, and in camelCase');\n  }\n\n  function componentWithNameValidator(props, propName, componentName) {\n    var propValue = props[propName];\n\n    if (props[propName] == null) {\n      return null;\n    }\n\n    for (var _len2 = arguments.length, rest = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n      rest[_key2 - 3] = arguments[_key2];\n    }\n\n    return hasName.apply(void 0, [name, namesOfHOCsToStrip, propValue, propName, componentName].concat(rest));\n  }\n\n  componentWithNameValidator.isRequired = function componentWithNameRequired(props, propName, componentName) {\n    var propValue = props[propName];\n\n    if (propValue == null) {\n      return new TypeError(\"`\".concat(componentName, \".\").concat(propName, \"` requires at least one component named \").concat(name));\n    }\n\n    for (var _len3 = arguments.length, rest = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n      rest[_key3 - 3] = arguments[_key3];\n    }\n\n    return hasName.apply(void 0, [name, namesOfHOCsToStrip, propValue, propName, componentName].concat(rest));\n  };\n\n  return (0, _wrapValidator[\"default\"])(componentWithNameValidator, \"componentWithName:\".concat(name), name);\n}","map":{"version":3,"sources":["../src/componentWithName.js"],"names":["innerName","HOC","previousHOC","namesOfHOCsToStrip","RegExp","rest","Array","hasName","React","type","propValue","componentNameFromType","innerComponentName","stripHOCs","name","options","passedOptions","Object","allHOCNamesAreValid","props","componentWithNameValidator"],"mappings":"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","sourcesContent":["import React from 'react';\nimport isRegex from 'is-regex';\nimport find from 'array.prototype.find';\n\nimport getComponentName from './helpers/getComponentName';\nimport wrapValidator from './helpers/wrapValidator';\n\nfunction stripHOCs(fullName, namesOfHOCsToStrip) {\n  let innerName = fullName;\n  while ((/\\([^()]*\\)/g).test(innerName)) {\n    let HOC = innerName;\n    let previousHOC;\n    do {\n      previousHOC = HOC;\n      HOC = previousHOC.replace(/\\([^()]*\\)/g, '');\n    } while (previousHOC !== HOC);\n\n    if (namesOfHOCsToStrip.indexOf(HOC) === -1) {\n      return innerName;\n    }\n    innerName = innerName.replace(RegExp(`^${HOC}\\\\(|\\\\)$`, 'g'), '');\n  }\n  return innerName;\n}\n\nfunction hasName(name, namesOfHOCsToStrip, propValue, propName, componentName, ...rest) {\n  if (Array.isArray(propValue)) {\n    return find(\n      propValue.map((item) => hasName(\n        name,\n        namesOfHOCsToStrip,\n        item,\n        propName,\n        componentName,\n        ...rest,\n      )),\n      Boolean,\n    ) || null;\n  }\n\n  if (!React.isValidElement(propValue)) {\n    return new TypeError(\n      `${componentName}.${propName} is not a valid React element`,\n    );\n  }\n\n  const { type } = propValue;\n  const componentNameFromType = getComponentName(type);\n  const innerComponentName = namesOfHOCsToStrip.length > 0\n    ? stripHOCs(componentNameFromType, namesOfHOCsToStrip)\n    : componentNameFromType;\n\n  if (isRegex(name) && !name.test(innerComponentName)) {\n    return new TypeError(\n      `\\`${componentName}.${propName}\\` only accepts components matching the regular expression ${name}`,\n    );\n  }\n\n  if (!isRegex(name) && innerComponentName !== name) {\n    return new TypeError(\n      `\\`${componentName}.${propName}\\` only accepts components named ${name}, got ${innerComponentName}`,\n    );\n  }\n\n  return null;\n}\n\nexport default function componentWithName(\n  name,\n  options = {},\n) {\n  if (typeof name !== 'string' && !isRegex(name)) {\n    throw new TypeError('name must be a string or a regex');\n  }\n\n  const passedOptions = Object.keys(options);\n  if (passedOptions.length > 1 || (passedOptions.length === 1 && passedOptions[0] !== 'stripHOCs')) {\n    throw new TypeError(`The only options supported are: “stripHOCs”, got: “${passedOptions.join('”, “')}”`);\n  }\n  const { stripHOCs: namesOfHOCsToStrip = [] } = options;\n\n  const allHOCNamesAreValid = namesOfHOCsToStrip.every((x) => {\n    if (typeof x !== 'string' || /[()]/g.test(x)) {\n      return false;\n    }\n    return /^(?:[a-z][a-zA-Z0-9]+|[A-Z][a-z][a-zA-Z0-9]+)$/.test(x);\n  });\n  if (!allHOCNamesAreValid) {\n    throw new TypeError('every provided HOC name must be a string with no parens, and in camelCase');\n  }\n\n  function componentWithNameValidator(props, propName, componentName, ...rest) {\n    const { [propName]: propValue } = props;\n    if (props[propName] == null) {\n      return null;\n    }\n    return hasName(name, namesOfHOCsToStrip, propValue, propName, componentName, ...rest);\n  }\n\n  componentWithNameValidator.isRequired = function componentWithNameRequired(\n    props,\n    propName,\n    componentName,\n    ...rest\n  ) {\n    const { [propName]: propValue } = props;\n    if (propValue == null) {\n      return new TypeError(`\\`${componentName}.${propName}\\` requires at least one component named ${name}`);\n    }\n    return hasName(name, namesOfHOCsToStrip, propValue, propName, componentName, ...rest);\n  };\n\n  return wrapValidator(componentWithNameValidator, `componentWithName:${name}`, name);\n}\n"]},"metadata":{},"sourceType":"script"}