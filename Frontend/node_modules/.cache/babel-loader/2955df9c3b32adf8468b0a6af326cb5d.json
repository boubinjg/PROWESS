{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('../GetIntrinsic.js');\n\nvar $construct = GetIntrinsic('%Reflect.construct%', true);\n\nvar DefinePropertyOrThrow = require('./DefinePropertyOrThrow');\n\ntry {\n  DefinePropertyOrThrow({}, '', {\n    '[[Get]]': function () {}\n  });\n} catch (e) {\n  // Accessor properties aren't supported\n  DefinePropertyOrThrow = null;\n} // https://ecma-international.org/ecma-262/6.0/#sec-isconstructor\n\n\nif (DefinePropertyOrThrow && $construct) {\n  var isConstructorMarker = {};\n  var badArrayLike = {};\n  DefinePropertyOrThrow(badArrayLike, 'length', {\n    '[[Get]]': function () {\n      throw isConstructorMarker;\n    },\n    '[[Enumerable]]': true\n  });\n\n  module.exports = function IsConstructor(argument) {\n    try {\n      // `Reflect.construct` invokes `IsConstructor(target)` before `Get(args, 'length')`:\n      $construct(argument, badArrayLike);\n    } catch (err) {\n      return err === isConstructorMarker;\n    }\n  };\n} else {\n  module.exports = function IsConstructor(argument) {\n    // unfortunately there's no way to truly check this without try/catch `new argument` in old environments\n    return typeof argument === 'function' && !!argument.prototype;\n  };\n}","map":{"version":3,"sources":["/home/jayson/Code/IoTLabScratchpad/IoTLabScheduler/Frontend/node_modules/es-abstract/2020/IsConstructor.js"],"names":["GetIntrinsic","require","$construct","DefinePropertyOrThrow","e","isConstructorMarker","badArrayLike","module","exports","IsConstructor","argument","err","prototype"],"mappings":"AAAA;;AAEA,IAAIA,YAAY,GAAGC,OAAO,CAAC,oBAAD,CAA1B;;AAEA,IAAIC,UAAU,GAAGF,YAAY,CAAC,qBAAD,EAAwB,IAAxB,CAA7B;;AAEA,IAAIG,qBAAqB,GAAGF,OAAO,CAAC,yBAAD,CAAnC;;AACA,IAAI;AACHE,EAAAA,qBAAqB,CAAC,EAAD,EAAK,EAAL,EAAS;AAAE,eAAW,YAAY,CAAE;AAA3B,GAAT,CAArB;AACA,CAFD,CAEE,OAAOC,CAAP,EAAU;AACX;AACAD,EAAAA,qBAAqB,GAAG,IAAxB;AACA,C,CAED;;;AAEA,IAAIA,qBAAqB,IAAID,UAA7B,EAAyC;AACxC,MAAIG,mBAAmB,GAAG,EAA1B;AACA,MAAIC,YAAY,GAAG,EAAnB;AACAH,EAAAA,qBAAqB,CAACG,YAAD,EAAe,QAAf,EAAyB;AAC7C,eAAW,YAAY;AACtB,YAAMD,mBAAN;AACA,KAH4C;AAI7C,sBAAkB;AAJ2B,GAAzB,CAArB;;AAOAE,EAAAA,MAAM,CAACC,OAAP,GAAiB,SAASC,aAAT,CAAuBC,QAAvB,EAAiC;AACjD,QAAI;AACH;AACAR,MAAAA,UAAU,CAACQ,QAAD,EAAWJ,YAAX,CAAV;AACA,KAHD,CAGE,OAAOK,GAAP,EAAY;AACb,aAAOA,GAAG,KAAKN,mBAAf;AACA;AACD,GAPD;AAQA,CAlBD,MAkBO;AACNE,EAAAA,MAAM,CAACC,OAAP,GAAiB,SAASC,aAAT,CAAuBC,QAAvB,EAAiC;AACjD;AACA,WAAO,OAAOA,QAAP,KAAoB,UAApB,IAAkC,CAAC,CAACA,QAAQ,CAACE,SAApD;AACA,GAHD;AAIA","sourcesContent":["'use strict';\n\nvar GetIntrinsic = require('../GetIntrinsic.js');\n\nvar $construct = GetIntrinsic('%Reflect.construct%', true);\n\nvar DefinePropertyOrThrow = require('./DefinePropertyOrThrow');\ntry {\n\tDefinePropertyOrThrow({}, '', { '[[Get]]': function () {} });\n} catch (e) {\n\t// Accessor properties aren't supported\n\tDefinePropertyOrThrow = null;\n}\n\n// https://ecma-international.org/ecma-262/6.0/#sec-isconstructor\n\nif (DefinePropertyOrThrow && $construct) {\n\tvar isConstructorMarker = {};\n\tvar badArrayLike = {};\n\tDefinePropertyOrThrow(badArrayLike, 'length', {\n\t\t'[[Get]]': function () {\n\t\t\tthrow isConstructorMarker;\n\t\t},\n\t\t'[[Enumerable]]': true\n\t});\n\n\tmodule.exports = function IsConstructor(argument) {\n\t\ttry {\n\t\t\t// `Reflect.construct` invokes `IsConstructor(target)` before `Get(args, 'length')`:\n\t\t\t$construct(argument, badArrayLike);\n\t\t} catch (err) {\n\t\t\treturn err === isConstructorMarker;\n\t\t}\n\t};\n} else {\n\tmodule.exports = function IsConstructor(argument) {\n\t\t// unfortunately there's no way to truly check this without try/catch `new argument` in old environments\n\t\treturn typeof argument === 'function' && !!argument.prototype;\n\t};\n}\n"]},"metadata":{},"sourceType":"script"}