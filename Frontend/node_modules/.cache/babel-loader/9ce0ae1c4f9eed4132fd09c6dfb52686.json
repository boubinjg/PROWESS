{"ast":null,"code":"'use strict';\n\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';\n\nvar isPrimitive = require('./helpers/isPrimitive');\n\nvar isCallable = require('is-callable');\n\nvar isDate = require('is-date-object');\n\nvar isSymbol = require('is-symbol');\n\nvar ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {\n  if (typeof O === 'undefined' || O === null) {\n    throw new TypeError('Cannot call method on ' + O);\n  }\n\n  if (typeof hint !== 'string' || hint !== 'number' && hint !== 'string') {\n    throw new TypeError('hint must be \"string\" or \"number\"');\n  }\n\n  var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];\n  var method, result, i;\n\n  for (i = 0; i < methodNames.length; ++i) {\n    method = O[methodNames[i]];\n\n    if (isCallable(method)) {\n      result = method.call(O);\n\n      if (isPrimitive(result)) {\n        return result;\n      }\n    }\n  }\n\n  throw new TypeError('No default value');\n};\n\nvar GetMethod = function GetMethod(O, P) {\n  var func = O[P];\n\n  if (func !== null && typeof func !== 'undefined') {\n    if (!isCallable(func)) {\n      throw new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');\n    }\n\n    return func;\n  }\n\n  return void 0;\n}; // http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive\n\n\nmodule.exports = function ToPrimitive(input) {\n  if (isPrimitive(input)) {\n    return input;\n  }\n\n  var hint = 'default';\n\n  if (arguments.length > 1) {\n    if (arguments[1] === String) {\n      hint = 'string';\n    } else if (arguments[1] === Number) {\n      hint = 'number';\n    }\n  }\n\n  var exoticToPrim;\n\n  if (hasSymbols) {\n    if (Symbol.toPrimitive) {\n      exoticToPrim = GetMethod(input, Symbol.toPrimitive);\n    } else if (isSymbol(input)) {\n      exoticToPrim = Symbol.prototype.valueOf;\n    }\n  }\n\n  if (typeof exoticToPrim !== 'undefined') {\n    var result = exoticToPrim.call(input, hint);\n\n    if (isPrimitive(result)) {\n      return result;\n    }\n\n    throw new TypeError('unable to convert exotic object to primitive');\n  }\n\n  if (hint === 'default' && (isDate(input) || isSymbol(input))) {\n    hint = 'string';\n  }\n\n  return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);\n};","map":{"version":3,"sources":["/home/boubin.2/PROWESS/Frontend/node_modules/es-to-primitive/es2015.js"],"names":["hasSymbols","Symbol","iterator","isPrimitive","require","isCallable","isDate","isSymbol","ordinaryToPrimitive","OrdinaryToPrimitive","O","hint","TypeError","methodNames","method","result","i","length","call","GetMethod","P","func","module","exports","ToPrimitive","input","arguments","String","Number","exoticToPrim","toPrimitive","prototype","valueOf"],"mappings":"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","sourcesContent":["'use strict';\n\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';\n\nvar isPrimitive = require('./helpers/isPrimitive');\nvar isCallable = require('is-callable');\nvar isDate = require('is-date-object');\nvar isSymbol = require('is-symbol');\n\nvar ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {\n\tif (typeof O === 'undefined' || O === null) {\n\t\tthrow new TypeError('Cannot call method on ' + O);\n\t}\n\tif (typeof hint !== 'string' || (hint !== 'number' && hint !== 'string')) {\n\t\tthrow new TypeError('hint must be \"string\" or \"number\"');\n\t}\n\tvar methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];\n\tvar method, result, i;\n\tfor (i = 0; i < methodNames.length; ++i) {\n\t\tmethod = O[methodNames[i]];\n\t\tif (isCallable(method)) {\n\t\t\tresult = method.call(O);\n\t\t\tif (isPrimitive(result)) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\tthrow new TypeError('No default value');\n};\n\nvar GetMethod = function GetMethod(O, P) {\n\tvar func = O[P];\n\tif (func !== null && typeof func !== 'undefined') {\n\t\tif (!isCallable(func)) {\n\t\t\tthrow new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');\n\t\t}\n\t\treturn func;\n\t}\n\treturn void 0;\n};\n\n// http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive\nmodule.exports = function ToPrimitive(input) {\n\tif (isPrimitive(input)) {\n\t\treturn input;\n\t}\n\tvar hint = 'default';\n\tif (arguments.length > 1) {\n\t\tif (arguments[1] === String) {\n\t\t\thint = 'string';\n\t\t} else if (arguments[1] === Number) {\n\t\t\thint = 'number';\n\t\t}\n\t}\n\n\tvar exoticToPrim;\n\tif (hasSymbols) {\n\t\tif (Symbol.toPrimitive) {\n\t\t\texoticToPrim = GetMethod(input, Symbol.toPrimitive);\n\t\t} else if (isSymbol(input)) {\n\t\t\texoticToPrim = Symbol.prototype.valueOf;\n\t\t}\n\t}\n\tif (typeof exoticToPrim !== 'undefined') {\n\t\tvar result = exoticToPrim.call(input, hint);\n\t\tif (isPrimitive(result)) {\n\t\t\treturn result;\n\t\t}\n\t\tthrow new TypeError('unable to convert exotic object to primitive');\n\t}\n\tif (hint === 'default' && (isDate(input) || isSymbol(input))) {\n\t\thint = 'string';\n\t}\n\treturn ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);\n};\n"]},"metadata":{},"sourceType":"script"}