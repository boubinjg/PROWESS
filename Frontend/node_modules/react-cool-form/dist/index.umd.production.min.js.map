{"version":3,"file":"index.umd.production.min.js","sources":["../node_modules/dequal/lite/index.mjs","../src/shared.ts","../src/hooks/useLatest.ts","../src/utils/arrayToMap.ts","../src/utils/isFileList.ts","../src/utils/isObject.ts","../src/utils/cloneObject.ts","../src/utils/compact.ts","../src/utils/isPlainObject.ts","../src/utils/deepMerge.ts","../src/utils/isUndefined.ts","../src/utils/filterErrors.ts","../src/utils/stringToPath.ts","../src/utils/get.ts","../src/utils/invariant.ts","../src/utils/isFunction.ts","../src/utils/isAsyncFunction.ts","../src/utils/isCheckboxInput.ts","../src/utils/isEmptyObject.ts","../src/utils/isFieldElement.ts","../src/utils/isFileInput.ts","../src/utils/isRadioInput.ts","../src/utils/isSelectMultiple.ts","../src/utils/set.ts","../src/utils/unset.ts","../src/hooks/useState.ts","../src/utils/getIsDirty.ts","../src/useFormState.ts","../src/useControlled.ts","../src/useForm.ts","../src/utils/isSelectOne.ts","../src/utils/isInputElement.ts","../src/utils/isNumberInput.ts","../src/utils/isRangeInput.ts","../src/utils/runWithLowPriority.ts","../src/useFormMethods.ts"],"sourcesContent":["var has = Object.prototype.hasOwnProperty;\n\nexport function dequal(foo, bar) {\n\tvar ctor, len;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n","import { Map, Methods } from \"./types\";\n\nlet one: Methods | undefined;\nconst all: Map<Methods> = {};\n\nexport const get = (id?: string): Methods => (id ? all[id] : (one as Methods));\n\nexport const set = (id: string | undefined, methods: Methods): void => {\n  if (id) {\n    all[id] = methods;\n  } else {\n    one = methods;\n  }\n};\n\nexport const remove = (id?: string): void => {\n  if (id) {\n    delete all[id];\n  } else {\n    one = undefined;\n  }\n};\n","import { MutableRefObject, useRef, useEffect } from \"react\";\n\nexport default <T>(val: T): MutableRefObject<T> => {\n  const ref = useRef(val);\n\n  useEffect(() => {\n    ref.current = val;\n  });\n\n  return ref;\n};\n","import { Map } from \"../types\";\n\nexport default (arr: any[]): Map =>\n  arr.reduce((obj, key) => {\n    obj[key] = true;\n    return obj;\n  }, {});\n","export default (value: unknown): value is FileList => value instanceof FileList;\n","export default (value: unknown): value is Object =>\n  value !== null && typeof value === \"object\";\n","import isFileList from \"./isFileList\";\nimport isObject from \"./isObject\";\n\nconst cloneObject = (object: unknown): any => {\n  if (object instanceof Event) throw new Error(\"Unable to clone event.\");\n\n  if (!isObject(object) || isFileList(object)) return object;\n\n  if (object instanceof Date) return new Date(object.getTime());\n\n  if (Array.isArray(object)) return object.map((val) => cloneObject(val));\n\n  return Object.keys(object).reduce((obj: Record<string, any>, key) => {\n    obj[key] = cloneObject((object as Record<string, any>)[key]);\n    return obj;\n  }, {});\n};\n\nexport default cloneObject;\n","export default (arr: any[]): any[] => arr.filter(Boolean);\n","import isObject from \"./isObject\";\n\nexport default (value: unknown): value is Object =>\n  !Array.isArray(value) && !(value instanceof Date) && isObject(value);\n","import isPlainObject from \"./isPlainObject\";\n\nconst deepMerge = (...objects: any[]): any =>\n  objects.reduce((prev, obj) => {\n    Object.keys(obj).forEach((key) => {\n      const prevValue = prev[key];\n      const currValue = obj[key];\n\n      if (Array.isArray(prevValue) && Array.isArray(currValue)) {\n        prev[key] = [...prevValue, ...currValue];\n      } else if (isPlainObject(prevValue) && isPlainObject(currValue)) {\n        prev[key] = deepMerge(prevValue, currValue);\n      } else {\n        prev[key] = currValue;\n      }\n    });\n\n    return prev;\n  }, {});\n\nexport default deepMerge;\n","export default (value: unknown): value is undefined => value === undefined;\n","import { Map } from \"../types\";\nimport isPlainObject from \"./isPlainObject\";\nimport isUndefined from \"./isUndefined\";\n\nconst filterErrors = (error: unknown, touched: unknown): any => {\n  if (!isPlainObject(error)) return touched ? error : undefined;\n\n  return Object.keys(error).reduce((obj: Map<any>, key) => {\n    const nextErrors = filterErrors(\n      (error as Map<any>)[key],\n      (touched as Map<any>)[key] || false\n    );\n\n    if (!isUndefined(nextErrors)) {\n      obj[key] = nextErrors;\n    } else {\n      delete obj[key];\n    }\n\n    return obj;\n  }, {});\n};\n\nexport default filterErrors;\n","import compact from \"./compact\";\n\nexport default (str: string): string[] => {\n  if (typeof str !== \"string\") throw new TypeError(\"Expected a string.\");\n  if (!str.length) return [];\n\n  return compact(str.split(/[.[\\]]+/));\n};\n","import isPlainObject from \"./isPlainObject\";\nimport isUndefined from \"./isUndefined\";\nimport stringToPath from \"./stringToPath\";\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport default (object: any, path: string, defaultValue?: unknown): any => {\n  if (!isPlainObject(object) || !path) return defaultValue;\n\n  const value = stringToPath(path).reduce(\n    (obj, key) => (obj || {})[key],\n    object\n  );\n\n  return !isUndefined(value) ? value : defaultValue;\n};\n","export default (condition: boolean, message: string): void => {\n  if (__DEV__ && condition) throw new Error(message);\n};\n","export default (value: unknown): value is Function =>\n  typeof value === \"function\";\n","import isFunction from \"./isFunction\";\n\nexport default (value: unknown): value is Promise<any> =>\n  isFunction(value) && value.constructor.name === \"AsyncFunction\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"checkbox\";\n","import { Map } from \"../types\";\nimport isPlainObject from \"./isPlainObject\";\n\nexport default (value: unknown): value is Map<never> =>\n  isPlainObject(value) && !Object.keys(value).length;\n","import { FieldElement } from \"../types\";\n\nexport default (element: HTMLElement): element is FieldElement =>\n  /INPUT|TEXTAREA|SELECT/.test(element.tagName);\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"file\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"radio\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLSelectElement =>\n  field.type === \"select-multiple\";\n","import cloneObject from \"./cloneObject\";\nimport isPlainObject from \"./isPlainObject\";\nimport stringToPath from \"./stringToPath\";\n\nexport default (\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  object: any,\n  path: string,\n  value: unknown,\n  immutable = false\n): any => {\n  if (!isPlainObject(object)) throw new TypeError(\"Expected an object.\");\n\n  const segs = stringToPath(path);\n  const newObject = immutable ? cloneObject(object) : object;\n\n  segs.slice(0, -1).reduce((obj, key, idx) => {\n    const nextIsNumber = !Number.isNaN(+segs[idx + 1]);\n    if (\n      (isPlainObject(obj[key]) && !nextIsNumber) ||\n      (Array.isArray(obj[key]) && nextIsNumber)\n    )\n      return obj[key];\n    obj[key] = nextIsNumber ? [] : {};\n    return obj[key];\n  }, newObject)[segs[segs.length - 1] || \"\"] = value;\n\n  return newObject;\n};\n","/* eslint-disable no-prototype-builtins */\n\nimport cloneObject from \"./cloneObject\";\nimport isEmptyObject from \"./isEmptyObject\";\nimport isPlainObject from \"./isPlainObject\";\nimport isUndefined from \"./isUndefined\";\nimport stringToPath from \"./stringToPath\";\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nconst unset = (object: any, path: string, immutable = false): any => {\n  if (!isPlainObject(object)) throw new TypeError(\"Expected an object.\");\n\n  const refObject = immutable ? cloneObject(object) : object;\n  const newObject = refObject;\n\n  if (newObject.hasOwnProperty(path)) {\n    delete newObject[path];\n    return refObject;\n  }\n\n  const segs = stringToPath(path);\n\n  if (!segs.length) return refObject;\n\n  const last = segs.pop() as string;\n  const target = segs.reduce((obj, key) => (obj || {})[key], newObject);\n\n  if (Array.isArray(target)) {\n    let index = +last;\n\n    if (index < target.length - 1) {\n      target.splice(index, 1);\n    } else {\n      while (index >= 0) {\n        // @ts-expect-error\n        if (index == last || isUndefined(target[index])) {\n          target.splice(index, 1);\n          index -= 1;\n        } else {\n          break;\n        }\n      }\n    }\n  } else if (isPlainObject(target)) {\n    delete target[last];\n  }\n\n  return isEmptyObject(target) || (Array.isArray(target) && !target.length)\n    ? unset(refObject, segs.join(\".\"))\n    : refObject;\n};\n\nexport default unset;\n","import { useReducer, useRef, useCallback } from \"react\";\nimport { dequal } from \"dequal/lite\";\n\nimport {\n  Debug,\n  FormState,\n  FormStateReturn,\n  Observer,\n  ObserverHandler,\n  SetStateRef,\n  SetUsedState,\n} from \"../types\";\nimport useLatest from \"./useLatest\";\nimport { get, getIsDirty, isEmptyObject, set } from \"../utils\";\n\nexport default <V>(\n  initialState: FormState<V>,\n  onChange?: Debug<V>\n): FormStateReturn<V> => {\n  const [, forceUpdate] = useReducer((c) => c + 1, 0);\n  const stateRef = useRef(initialState);\n  const stateObserversRef = useRef<Observer[]>([\n    { usedState: {}, update: forceUpdate },\n  ]);\n  const onChangeRef = useLatest(onChange || (() => undefined));\n\n  const setStateRef = useCallback<SetStateRef>(\n    (path, value, { fieldPath, shouldUpdate = true } = {}) => {\n      const key = path.split(\".\")[0];\n\n      if (!key) {\n        if (!dequal(stateRef.current, value)) {\n          stateRef.current = value;\n          onChangeRef.current(stateRef.current);\n\n          stateObserversRef.current.forEach(({ usedState, update }) => {\n            if (shouldUpdate && !isEmptyObject(usedState)) update();\n          });\n        }\n\n        return;\n      }\n\n      if (\n        (path !== \"values\" && key === \"values\") ||\n        !dequal(get(stateRef.current, path), value)\n      ) {\n        const state = set(stateRef.current, path, value, true);\n        const {\n          errors,\n          dirty,\n          isDirty: prevIsDirty,\n          isValid: prevIsValid,\n        } = state;\n        let { submitCount: prevSubmitCount } = state;\n        const isDirty = key === \"dirty\" ? getIsDirty(dirty) : prevIsDirty;\n        const isValid = key === \"errors\" ? isEmptyObject(errors) : prevIsValid;\n        const submitCount =\n          key === \"isSubmitting\" && value\n            ? (prevSubmitCount += 1)\n            : prevSubmitCount;\n\n        stateRef.current = { ...state, isDirty, isValid, submitCount };\n        onChangeRef.current(stateRef.current);\n\n        if (!shouldUpdate) return;\n\n        path = fieldPath || path;\n        stateObserversRef.current.forEach(({ usedState, update }) => {\n          if (\n            Object.keys(usedState).some(\n              (k) => path.startsWith(k) || k.startsWith(path)\n            ) ||\n            (usedState.isDirty && isDirty !== prevIsDirty) ||\n            (usedState.isValid && isValid !== prevIsValid)\n          )\n            update();\n        });\n      }\n    },\n    [onChangeRef]\n  );\n\n  const setUsedState = useCallback<SetUsedState>((usedState) => {\n    stateObserversRef.current[0].usedState = usedState;\n  }, []);\n\n  const subscribeObserver = useCallback<ObserverHandler>(\n    (observer) => stateObserversRef.current.push(observer),\n    []\n  );\n\n  const unsubscribeObserver = useCallback<ObserverHandler>((observer) => {\n    stateObserversRef.current = stateObserversRef.current.filter(\n      (o) => o !== observer\n    );\n  }, []);\n\n  return {\n    stateRef,\n    setStateRef,\n    setUsedState,\n    subscribeObserver,\n    unsubscribeObserver,\n  };\n};\n","import isObject from \"./isObject\";\n\nconst getIsDirty = (dirty: object): boolean => {\n  const search = (dty: object, found: any[] = []) => {\n    for (const val of Object.values(dty)) {\n      if (val === true) {\n        found.push(val);\n        return found;\n      }\n\n      if (isObject(val)) search(val, found);\n    }\n\n    return found;\n  };\n\n  return !!search(dirty).length;\n};\n\nexport default getIsDirty;\n","/* eslint-disable react-hooks/rules-of-hooks */\n\nimport { useEffect, useReducer, useRef } from \"react\";\n\nimport { FormStateConfig, FormValues, Observer, Path } from \"./types\";\nimport { get } from \"./shared\";\nimport { invariant } from \"./utils\";\n\nexport default <V extends FormValues = FormValues>(\n  path: Path,\n  { formId, ...rest }: FormStateConfig<V> = {}\n): any => {\n  const methods = get(formId);\n  const methodName = \"useFormState\";\n\n  invariant(\n    !methods,\n    `💡 react-cool-form > ${methodName}: You must provide the corresponding ID to \"useForm\" hook. See: https://react-cool-form.netlify.app/docs/api-reference/use-form#id`\n  );\n\n  const observerRef = useRef<Observer>();\n  const [, forceUpdate] = useReducer((c) => c + 1, 0);\n  const { getFormState, subscribeObserver, unsubscribeObserver } = methods;\n\n  useEffect(() => {\n    // @ts-expect-error\n    subscribeObserver(observerRef.current);\n\n    // @ts-expect-error\n    return () => unsubscribeObserver(observerRef.current);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return getFormState(path, {\n    ...rest,\n    methodName,\n    callback: (usedState) => {\n      if (!observerRef.current)\n        observerRef.current = { usedState, update: forceUpdate };\n    },\n  });\n};\n","import { useEffect, useRef } from \"react\";\n\nimport { ControlledConfig, ControlledReturn, FormValues } from \"./types\";\nimport * as shared from \"./shared\";\nimport { get, invariant, isFieldElement, isUndefined, warn } from \"./utils\";\nimport useFormState from \"./useFormState\";\n\nexport default <V extends FormValues = FormValues>(\n  name: string,\n  {\n    formId,\n    defaultValue,\n    validate,\n    parse,\n    format,\n    errorWithTouched,\n    ...props\n  }: ControlledConfig<V> = {}\n): ControlledReturn => {\n  invariant(\n    !name,\n    '💡 react-cool-form > useControlled: Missing \"name\" parameter.'\n  );\n\n  const methods = shared.get(formId);\n\n  invariant(\n    !methods,\n    '💡 react-cool-form > useControlled: You must provide the corresponding ID to \"useForm\" hook. See: https://react-cool-form.netlify.app/docs/api-reference/use-form#id'\n  );\n\n  const hasWarn = useRef(false);\n  const meta = useFormState(\n    {\n      value: `values.${name}`,\n      error: `errors.${name}`,\n      isTouched: `touched.${name}`,\n      isDirty: `dirty.${name}`,\n    },\n    { formId, errorWithTouched }\n  );\n  const {\n    shouldRemoveField,\n    defaultValuesRef,\n    initialStateRef,\n    controlledsRef,\n    fieldValidatorsRef,\n    changedFieldRef,\n    getNodeValue,\n    setDefaultValue,\n    setTouchedMaybeValidate,\n    handleChangeEvent,\n    removeField,\n  } = methods;\n\n  useEffect(\n    () => () => {\n      if (shouldRemoveField) removeField(name);\n    },\n    [name, removeField, shouldRemoveField]\n  );\n\n  controlledsRef.current[name] = true;\n  if (validate) fieldValidatorsRef.current[name] = validate;\n\n  let value;\n\n  if (isUndefined(get(initialStateRef.current.values, name))) {\n    value = get(defaultValuesRef.current, name);\n    value = !isUndefined(value) ? value : defaultValue;\n\n    if (!isUndefined(value)) {\n      setDefaultValue(name, value);\n    } else if (!hasWarn.current) {\n      warn(\n        `💡 react-cool-form > useControlled: Please provide a default value for \"${name}\" field.`\n      );\n      hasWarn.current = true;\n    }\n  }\n\n  value = !isUndefined(meta.value) ? meta.value : value;\n  value = (format ? format(value) : value) ?? \"\";\n  const { onChange, onBlur, ...restProps } = props;\n\n  return [\n    {\n      name,\n      value,\n      onChange: (...event) => {\n        let val;\n\n        if (parse) {\n          val = parse(...event);\n        } else {\n          const e = event[0];\n          val =\n            e?.nativeEvent instanceof Event && isFieldElement(e.target)\n              ? getNodeValue(name)\n              : e;\n        }\n\n        handleChangeEvent(name, val);\n        if (onChange) onChange(...event);\n        changedFieldRef.current = name;\n      },\n      onBlur: (e) => {\n        setTouchedMaybeValidate(name);\n        if (onBlur) onBlur(e);\n        changedFieldRef.current = undefined;\n      },\n      ...restProps,\n    },\n    { error: meta.error, isTouched: !!meta.isTouched, isDirty: !!meta.isDirty },\n  ];\n};\n","/* eslint-disable @typescript-eslint/no-use-before-define */\n\nimport { useCallback, useEffect, useRef } from \"react\";\nimport { dequal } from \"dequal/lite\";\n\nimport * as shared from \"./shared\";\nimport {\n  ClearErrors,\n  Field,\n  FieldElement,\n  Fields,\n  FieldValidator,\n  FormConfig,\n  FormErrors,\n  FormMethods,\n  FormState,\n  FormValues,\n  GetFormState,\n  GetNodeValue,\n  GetState,\n  HandleChangeEvent,\n  Handlers,\n  Map,\n  Parsers,\n  RegisterField,\n  RegisterForm,\n  RemoveField,\n  Reset,\n  RunValidation,\n  Select,\n  SetDefaultValue,\n  SetDirty,\n  SetError,\n  SetTouched,\n  SetTouchedMaybeValidate,\n  SetValue,\n  Submit,\n} from \"./types\";\nimport { useLatest, useState } from \"./hooks\";\nimport {\n  arrayToMap,\n  compact,\n  deepMerge,\n  filterErrors,\n  get,\n  isAsyncFunction,\n  isCheckboxInput,\n  isEmptyObject,\n  isFieldElement,\n  isFileInput,\n  isFileList,\n  isFunction,\n  isInputElement,\n  isNumberInput,\n  isPlainObject,\n  isRadioInput,\n  isRangeInput,\n  isSelectMultiple,\n  isSelectOne,\n  isUndefined,\n  runWithLowPriority,\n  set,\n  unset,\n  warn,\n} from \"./utils\";\n\nexport default <V extends FormValues = FormValues>({\n  id,\n  defaultValues = {} as V,\n  validate,\n  validateOnChange = true,\n  validateOnBlur = true,\n  builtInValidationMode = \"message\",\n  shouldRemoveField = true,\n  excludeFields = [],\n  onReset,\n  onSubmit,\n  onError,\n  debug,\n}: FormConfig<V> = {}): FormMethods<V> => {\n  const handlersRef = useRef<Handlers>({});\n  const observerRef = useRef<MutationObserver>();\n  const formRef = useRef<HTMLElement>();\n  const fieldsRef = useRef<Fields>({});\n  const fieldParsersRef = useRef<Parsers>({});\n  const controlledsRef = useRef<Map>({});\n  const excludeFieldsRef = useRef<Map>(arrayToMap(excludeFields));\n  const changedFieldRef = useRef<string>();\n  const formValidatorRef = useLatest(validate);\n  const fieldValidatorsRef = useRef<Map<FieldValidator<V>>>({});\n  const onResetRef = useLatest(onReset || (() => undefined));\n  const onSubmitRef = useLatest(onSubmit || (() => undefined));\n  const onErrorRef = useLatest(onError || (() => undefined));\n  const defaultValuesRef = useRef(defaultValues);\n  const initialStateRef = useRef<FormState<V>>({\n    values: defaultValuesRef.current,\n    touched: {},\n    errors: {},\n    isDirty: false,\n    dirty: {},\n    isValidating: false,\n    isValid: true,\n    isSubmitting: false,\n    isSubmitted: false,\n    submitCount: 0,\n  });\n  const {\n    stateRef,\n    setStateRef,\n    setUsedState,\n    subscribeObserver,\n    unsubscribeObserver,\n  } = useState<V>(initialStateRef.current, debug);\n\n  const handleUnset = useCallback(\n    (path: string) => {\n      const [t, n] = path.split(\".\");\n      setStateRef(\n        t,\n        unset(stateRef.current[t as keyof FormState<V>], n, true),\n        {\n          fieldPath: path,\n        }\n      );\n    },\n    [setStateRef, stateRef]\n  );\n\n  const getFields = useCallback(\n    (form: HTMLElement) =>\n      Array.from(form.querySelectorAll(\"input,textarea,select\"))\n        .filter((element) => {\n          const field = element as FieldElement;\n          const {\n            type,\n            name,\n            id: fieldId,\n            classList,\n            dataset: { rcfExclude },\n          } = field;\n\n          const classes = Array.from(classList);\n          const { current: exclude } = excludeFieldsRef;\n\n          if (\n            /button|image|submit|reset/.test(type) ||\n            (fieldId && exclude[`#${fieldId}`]) ||\n            classes.find((n) => exclude[`.${n}`])\n          )\n            return false;\n\n          if (rcfExclude !== \"true\" && !name) {\n            warn(\n              '💡 react-cool-form > field: Missing \"name\" attribute. Do you want to exclude the field? See: https://react-cool-form.netlify.app/docs/api-reference/use-form/#excludefields'\n            );\n            return false;\n          }\n\n          return (\n            controlledsRef.current[name] ||\n            (rcfExclude !== \"true\" && !exclude[name])\n          );\n        })\n        .reduce((acc: Fields, elm) => {\n          const field = elm as FieldElement;\n          const { name } = field;\n\n          acc[name] = { ...acc[name], field: acc[name]?.field || field };\n\n          if (isCheckboxInput(field) || isRadioInput(field)) {\n            acc[name].options = acc[name].options\n              ? [...(acc[name].options as HTMLInputElement[]), field]\n              : [field];\n          } else if (isSelectOne(field) || isSelectMultiple(field)) {\n            acc[name].options = Array.from(field.options);\n          }\n\n          return acc;\n        }, {}),\n    []\n  );\n\n  const getNodeValue = useCallback<GetNodeValue>(\n    (name, fields = fieldsRef.current) => {\n      const { field, options } = fields[name];\n      let value = field.value as any;\n\n      if (isInputElement(field)) {\n        if (fieldParsersRef.current[name]?.valueAsNumber) {\n          value = field.valueAsNumber;\n          return value;\n        }\n        if (fieldParsersRef.current[name]?.valueAsDate) {\n          value = field.valueAsDate;\n          return value;\n        }\n      }\n\n      if (isNumberInput(field) || isRangeInput(field))\n        value = field.valueAsNumber || \"\";\n\n      if (isCheckboxInput(field)) {\n        const checkboxes = options as HTMLInputElement[];\n        const checkbox = checkboxes[0];\n\n        if (checkboxes.length > 1) {\n          value = checkboxes.filter((c) => c.checked).map((c) => c.value);\n        } else if (checkbox.hasAttribute(\"value\") && checkbox.value) {\n          value = checkbox.checked ? [checkbox.value] : [];\n        } else {\n          value = checkbox.checked;\n        }\n      }\n\n      if (isRadioInput(field))\n        value =\n          (options as HTMLInputElement[]).find((radio) => radio.checked)\n            ?.value || \"\";\n\n      if (isSelectMultiple(field))\n        value = (options as HTMLOptionElement[])\n          .filter((option) => option.selected)\n          .map((option) => option.value);\n\n      if (isFileInput(field)) value = field.files;\n\n      return value;\n    },\n    []\n  );\n\n  const setNodeValue = useCallback(\n    (name: string, value: any, fields: Fields = fieldsRef.current) => {\n      if (!fields[name] || controlledsRef.current[name]) return;\n\n      const { field, options } = fields[name];\n\n      if (isCheckboxInput(field)) {\n        const checkboxes = options as HTMLInputElement[];\n\n        if (checkboxes.length > 1) {\n          checkboxes.forEach((checkbox) => {\n            checkbox.checked = Array.isArray(value)\n              ? value.includes(checkbox.value)\n              : !!value;\n          });\n        } else {\n          checkboxes[0].checked = !!value;\n        }\n      } else if (isRadioInput(field)) {\n        (options as HTMLInputElement[]).forEach((radio) => {\n          radio.checked = radio.value === value;\n        });\n      } else if (isSelectMultiple(field) && Array.isArray(value)) {\n        (options as HTMLOptionElement[]).forEach((option) => {\n          option.selected = !!value.includes(option.value);\n        });\n      } else if (isFileInput(field)) {\n        if (isFileList(value)) field.files = value;\n        if (!value) field.value = \"\";\n      } else {\n        field.value = value ?? \"\";\n      }\n    },\n    []\n  );\n\n  const setDefaultValue = useCallback<SetDefaultValue>(\n    (name, value) => {\n      initialStateRef.current = set(\n        initialStateRef.current,\n        `values.${name}`,\n        value,\n        true\n      );\n\n      setStateRef(`values.${name}`, value, { shouldUpdate: false });\n    },\n    [setStateRef]\n  );\n\n  const setNodesOrStateValue = useCallback(\n    (\n      values: V,\n      {\n        shouldUpdateDefaultValues = true,\n        fields = Object.values(fieldsRef.current),\n      }: {\n        shouldUpdateDefaultValues?: boolean;\n        fields?: Field[] | string[];\n      } = {}\n    ) =>\n      fields.forEach((field: Field | string) => {\n        const name = isPlainObject(field) ? (field as Field).field.name : field;\n\n        if (controlledsRef.current[name]) return;\n\n        let value = get(values, name);\n\n        if (!isUndefined(value)) setNodeValue(name, value);\n\n        if (shouldUpdateDefaultValues) {\n          value = get(defaultValuesRef.current, name);\n\n          setDefaultValue(\n            name,\n            !isUndefined(value) ? value : getNodeValue(name)\n          );\n        }\n      }),\n    [getNodeValue, setDefaultValue, setNodeValue]\n  );\n\n  const getFormState = useCallback<GetFormState<V>>(\n    (\n      path,\n      {\n        target,\n        errorWithTouched,\n        defaultValues: dfValues = {},\n        methodName = \"select\",\n        callback,\n      }\n    ) => {\n      if (!path) return callback ? undefined : stateRef.current;\n\n      const usedState: Map = {};\n      const getPath = (p: string) => {\n        p = target ? `${target}.${p}` : p;\n\n        if (callback) {\n          if (p === \"values\")\n            warn(\n              `💡 react-cool-form > ${methodName}: Getting \"values\" alone might cause unnecessary re-renders. If you know what you're doing, please ignore this warning. See: https://react-cool-form.netlify.app/docs/getting-started/form-state#best-practices`\n            );\n\n          usedState[p] = true;\n        }\n\n        return p;\n      };\n      const helper = (p: string, state: any) => {\n        if (p.startsWith(\"values\")) {\n          if (!isUndefined(state)) return state;\n\n          p = p.replace(\"values.\", \"\");\n          state = get(defaultValuesRef.current, p);\n\n          return !isUndefined(state) ? state : get(dfValues, p);\n        }\n\n        if (\n          !errorWithTouched ||\n          !p.startsWith(\"errors\") ||\n          !state ||\n          isEmptyObject(state)\n        )\n          return state;\n\n        p = p.replace(\"errors\", \"touched\");\n        usedState[p] = true;\n\n        return filterErrors(state, get(stateRef.current, p));\n      };\n      let state;\n\n      if (Array.isArray(path)) {\n        state = path.map((p) => {\n          p = getPath(p);\n          return helper(p, get(stateRef.current, p));\n        });\n      } else if (isPlainObject(path)) {\n        const paths = path as Map<string>;\n        state = Object.keys(paths).reduce((s: Map<any>, key) => {\n          path = getPath(paths[key]);\n          s[key] = helper(path, get(stateRef.current, path));\n          return s;\n        }, {});\n      } else {\n        path = getPath(path);\n        state = helper(path, get(stateRef.current, path));\n      }\n\n      if (callback) callback(usedState);\n\n      return state;\n    },\n    [stateRef]\n  );\n\n  const select = useCallback<Select<V>>(\n    (path, { target, errorWithTouched, defaultValues: dfValues } = {}) =>\n      getFormState(path, {\n        target,\n        errorWithTouched,\n        defaultValues: dfValues,\n        callback: (usedState) => setUsedState(usedState),\n      }),\n    [getFormState, setUsedState]\n  );\n\n  const getState = useCallback<GetState>(\n    (path, target) => getFormState(path, { target }),\n    [getFormState]\n  );\n\n  const setError = useCallback<SetError>(\n    (name, error) => {\n      error = isFunction(error)\n        ? error(get(stateRef.current.errors, name))\n        : error;\n\n      if (error) {\n        setStateRef(`errors.${name}`, error);\n      } else {\n        handleUnset(`errors.${name}`);\n      }\n    },\n    [handleUnset, setStateRef, stateRef]\n  );\n\n  const clearErrors = useCallback<ClearErrors>(\n    (name) => {\n      if (!name) {\n        setStateRef(\"errors\", {});\n      } else if (Array.isArray(name)) {\n        name.forEach((n) => setError(n));\n      } else {\n        setError(name);\n      }\n    },\n    [setError, setStateRef]\n  );\n\n  const runBuiltInValidation = useCallback(\n    (name: string) => {\n      if (builtInValidationMode === false || !fieldsRef.current[name])\n        return undefined;\n\n      const { field } = fieldsRef.current[name];\n\n      if (builtInValidationMode === \"message\") return field.validationMessage;\n\n      for (const k in field.validity) // @ts-expect-error\n        if (k !== \"valid\" && field.validity[k]) return k;\n\n      return undefined;\n    },\n    [builtInValidationMode]\n  );\n\n  const runAllBuiltInValidation = useCallback(() => {\n    if (builtInValidationMode === false) return {};\n\n    return Object.keys(fieldsRef.current).reduce((errors, name) => {\n      const error = runBuiltInValidation(name);\n      errors = { ...errors, ...(error ? set({}, name, error) : {}) };\n      return errors;\n    }, {});\n  }, [builtInValidationMode, runBuiltInValidation]);\n\n  const runFieldValidation = useCallback(\n    async (name: string): Promise<any> => {\n      if (!fieldValidatorsRef.current[name]) return undefined;\n\n      try {\n        const error = await fieldValidatorsRef.current[name](\n          get(stateRef.current.values, name),\n          stateRef.current.values\n        );\n\n        return error;\n      } catch (exception) {\n        warn(`💡 react-cool-form > validate ${name}: `, exception);\n        throw exception;\n      }\n    },\n    [stateRef]\n  );\n\n  const runAllFieldsValidation = useCallback((): Promise<FormErrors<V>> => {\n    const promises = Object.keys(fieldValidatorsRef.current).map((name) =>\n      runFieldValidation(name)\n    );\n\n    return Promise.all(promises).then((errors) =>\n      Object.keys(fieldValidatorsRef.current).reduce((acc, cur, idx) => {\n        acc = { ...acc, ...(errors[idx] ? set({}, cur, errors[idx]) : {}) };\n        return acc;\n      }, {})\n    );\n  }, [runFieldValidation]);\n\n  const runFormValidation = useCallback(\n    async (name?: string): Promise<any> => {\n      if (!formValidatorRef.current) return name ? undefined : {};\n\n      try {\n        const errors = await formValidatorRef.current(stateRef.current.values);\n\n        if (name) return get(errors, name);\n\n        return isPlainObject(errors) ? errors : {};\n      } catch (exception) {\n        warn(`💡 react-cool-form > validate form: `, exception);\n        throw exception;\n      }\n    },\n    [formValidatorRef, stateRef]\n  );\n\n  const validateField = useCallback(\n    async (name: string) => {\n      const hasAsyncValidator =\n        isAsyncFunction(formValidatorRef.current) ||\n        isAsyncFunction(fieldValidatorsRef.current[name]);\n\n      if (hasAsyncValidator) setStateRef(\"isValidating\", true);\n\n      try {\n        const error =\n          (await runFormValidation(name)) ||\n          (await runFieldValidation(name)) ||\n          runBuiltInValidation(name);\n\n        setError(name, error);\n        if (hasAsyncValidator) setStateRef(\"isValidating\", false);\n\n        return error;\n      } catch (exception) {\n        return exception;\n      }\n    },\n    [\n      formValidatorRef,\n      runBuiltInValidation,\n      runFieldValidation,\n      runFormValidation,\n      setError,\n      setStateRef,\n    ]\n  );\n\n  const validateFieldWithLowPriority = useCallback<typeof validateField>(\n    (name) => runWithLowPriority(() => validateField(name)),\n    [validateField]\n  );\n\n  const validateForm = useCallback((): Promise<FormErrors<V>> => {\n    setStateRef(\"isValidating\", true);\n\n    return Promise.all([\n      runAllBuiltInValidation(),\n      runAllFieldsValidation(),\n      runFormValidation(),\n    ]).then((errors) => {\n      const errs = deepMerge(...errors);\n\n      setStateRef(\"errors\", errs);\n      setStateRef(\"isValidating\", false);\n\n      return errs;\n    });\n  }, [\n    runAllBuiltInValidation,\n    runAllFieldsValidation,\n    runFormValidation,\n    setStateRef,\n  ]);\n\n  const runValidation = useCallback<RunValidation>(\n    (name) => {\n      if (!name) return validateForm().then((errors) => isEmptyObject(errors));\n\n      if (Array.isArray(name))\n        return Promise.all(name.map((n) => validateField(n))).then(\n          (errors) => !compact(errors).length\n        );\n\n      return validateField(name).then((error) => !error);\n    },\n    [validateField, validateForm]\n  );\n\n  const setTouched = useCallback<SetTouched>(\n    (name, isTouched = true, shouldValidate = validateOnBlur) => {\n      if (isTouched) {\n        setStateRef(`touched.${name}`, true);\n      } else {\n        handleUnset(`touched.${name}`);\n      }\n\n      if (shouldValidate) validateFieldWithLowPriority(name);\n    },\n    [handleUnset, setStateRef, validateFieldWithLowPriority, validateOnBlur]\n  );\n\n  const setTouchedMaybeValidate = useCallback<SetTouchedMaybeValidate>(\n    (name) =>\n      setTouched(\n        name,\n        true,\n        validateOnChange ? name !== changedFieldRef.current : undefined\n      ),\n    [setTouched, validateOnChange]\n  );\n\n  const setDirty = useCallback<SetDirty>(\n    (name, isDirty = true) => {\n      if (isDirty) {\n        setStateRef(`dirty.${name}`, true);\n      } else {\n        handleUnset(`dirty.${name}`);\n      }\n    },\n    [handleUnset, setStateRef]\n  );\n\n  const setDirtyIfNeeded = useCallback(\n    (name: string) =>\n      setDirty(\n        name,\n        !dequal(\n          get(stateRef.current.values, name),\n          get(initialStateRef.current.values, name)\n        )\n      ),\n    [setDirty, stateRef]\n  );\n\n  const setValue = useCallback<SetValue>(\n    (\n      name,\n      value,\n      {\n        shouldValidate = validateOnChange,\n        shouldTouched = true,\n        shouldDirty = true,\n      } = {}\n    ) => {\n      value = isFunction(value)\n        ? value(get(stateRef.current.values, name))\n        : value;\n\n      if (!isUndefined(value)) {\n        setStateRef(`values.${name}`, value);\n      } else {\n        handleUnset(`values.${name}`);\n      }\n      setNodeValue(name, value);\n\n      if (shouldTouched) setTouched(name, true, false);\n      if (shouldDirty) setDirtyIfNeeded(name);\n      if (shouldValidate) validateFieldWithLowPriority(name);\n    },\n    [\n      handleUnset,\n      setDirtyIfNeeded,\n      setNodeValue,\n      setStateRef,\n      setTouched,\n      stateRef,\n      validateFieldWithLowPriority,\n      validateOnChange,\n    ]\n  );\n\n  const getOptions = useCallback(\n    () => ({\n      getState,\n      setValue,\n      setTouched,\n      setDirty,\n      setError,\n      clearErrors,\n      runValidation,\n      reset,\n      submit,\n    }),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  const reset: Reset<V> = useCallback(\n    (values, exclude, e) => {\n      if (e?.preventDefault) e.preventDefault();\n      if (e?.stopPropagation) e.stopPropagation();\n\n      const state = { ...stateRef.current };\n      const skip = arrayToMap(exclude || []);\n\n      Object.keys(state).forEach((key) => {\n        if (skip[key]) return;\n\n        if (key === \"values\") {\n          const nextValues =\n            (isFunction(values) ? values(stateRef.current.values) : values) ||\n            initialStateRef.current.values;\n\n          state[key] = nextValues;\n          initialStateRef.current = set(\n            initialStateRef.current,\n            \"values\",\n            nextValues,\n            true\n          );\n          setNodesOrStateValue(nextValues, {\n            shouldUpdateDefaultValues: false,\n          });\n        } else {\n          // @ts-expect-error\n          state[key] = initialStateRef.current[key];\n        }\n      });\n\n      setStateRef(\"\", state);\n      onResetRef.current(state.values, getOptions(), e);\n    },\n    [getOptions, onResetRef, setNodesOrStateValue, setStateRef, stateRef]\n  );\n\n  const submit: Submit<V> = useCallback(\n    async (e) => {\n      if (e?.preventDefault) e.preventDefault();\n      if (e?.stopPropagation) e.stopPropagation();\n\n      const nextTouched = Object.keys({\n        ...fieldsRef.current,\n        ...controlledsRef.current,\n      }).reduce((touched, name) => {\n        touched = set(touched, name, true, true);\n        return touched;\n      }, stateRef.current.touched);\n\n      setStateRef(\"touched\", nextTouched);\n      setStateRef(\"isSubmitting\", true);\n\n      try {\n        const errors = await validateForm();\n\n        if (!isEmptyObject(errors)) {\n          onErrorRef.current(errors, getOptions(), e);\n\n          return { errors };\n        }\n\n        await onSubmitRef.current(stateRef.current.values, getOptions(), e);\n        setStateRef(\"isSubmitted\", true);\n\n        return { values: stateRef.current.values };\n      } catch (exception) {\n        warn(`💡 react-cool-form > submit: `, exception);\n        throw exception;\n      } finally {\n        setStateRef(\"isSubmitting\", false);\n      }\n    },\n    [getOptions, onErrorRef, onSubmitRef, setStateRef, stateRef, validateForm]\n  );\n\n  const handleChangeEvent = useCallback<HandleChangeEvent>(\n    (name, value) => {\n      setStateRef(`values.${name}`, value);\n      setDirtyIfNeeded(name);\n\n      if (validateOnChange) validateFieldWithLowPriority(name);\n    },\n    [\n      setDirtyIfNeeded,\n      setStateRef,\n      validateFieldWithLowPriority,\n      validateOnChange,\n    ]\n  );\n\n  const removeField = useCallback<RemoveField>(\n    (name) => {\n      handleUnset(`values.${name}`);\n      handleUnset(`touched.${name}`);\n      handleUnset(`dirty.${name}`);\n      handleUnset(`errors.${name}`);\n\n      initialStateRef.current = unset(\n        initialStateRef.current,\n        `values.${name}`,\n        true\n      );\n\n      delete fieldParsersRef.current[name];\n      delete fieldValidatorsRef.current[name];\n      delete controlledsRef.current[name];\n    },\n    [handleUnset]\n  );\n\n  const registerForm = useCallback<RegisterForm>(\n    (el) => {\n      if (!el) return;\n\n      formRef.current = el;\n      const form = formRef.current;\n\n      fieldsRef.current = getFields(form);\n      setNodesOrStateValue(initialStateRef.current.values);\n\n      handlersRef.current.change = ({ target }: Event) => {\n        const { name } = target as FieldElement;\n\n        if (!name) {\n          warn('💡 react-cool-form > field: Missing \"name\" attribute.');\n          return;\n        }\n\n        if (fieldsRef.current[name] && !controlledsRef.current[name]) {\n          const parse = fieldParsersRef.current[name]?.parse;\n          const value = getNodeValue(name);\n\n          handleChangeEvent(name, parse ? parse(value) : value);\n          changedFieldRef.current = name;\n        }\n      };\n\n      handlersRef.current.blur = ({ target }: Event) => {\n        if (!isFieldElement(target as HTMLElement)) return;\n\n        const { name } = target as FieldElement;\n\n        if (fieldsRef.current[name] && !controlledsRef.current[name]) {\n          setTouchedMaybeValidate(name);\n          changedFieldRef.current = undefined;\n        }\n      };\n\n      handlersRef.current.submit = (e: Event) => submit(e as any);\n\n      handlersRef.current.reset = (e: Event) => reset(null, null, e as any);\n\n      form.addEventListener(\"input\", handlersRef.current.change);\n      form.addEventListener(\"focusout\", handlersRef.current.blur);\n      form.addEventListener(\"submit\", handlersRef.current.submit);\n      form.addEventListener(\"reset\", handlersRef.current.reset);\n\n      observerRef.current = new MutationObserver(([{ type }]) => {\n        if (type !== \"childList\") return;\n\n        const fields = getFields(form);\n\n        if (shouldRemoveField)\n          Object.keys(fieldsRef.current).forEach((name) => {\n            if (controlledsRef.current[name]) return;\n\n            if (!fields[name]) {\n              removeField(name);\n              return;\n            }\n\n            const currOptions = fieldsRef.current[name].options\n              ?.length as number;\n            const nextOptions = fields[name].options?.length as number;\n\n            if (currOptions > nextOptions) {\n              setStateRef(`values.${name}`, getNodeValue(name, fields), {\n                shouldUpdate: false,\n              });\n            } else if (currOptions < nextOptions) {\n              setNodeValue(\n                name,\n                get(initialStateRef.current.values, name),\n                fields\n              );\n            }\n          });\n\n        let values = defaultValuesRef.current;\n        const addedNodes: string[] = [];\n\n        Object.keys(fields).forEach((name) => {\n          if (fieldsRef.current[name] || controlledsRef.current[name]) return;\n\n          const value = get(stateRef.current.values, name);\n          if (!isUndefined(value)) values = set(values, name, value, true);\n\n          addedNodes.push(name);\n        });\n\n        fieldsRef.current = fields;\n        if (addedNodes.length)\n          setNodesOrStateValue(values, { fields: addedNodes });\n      });\n\n      observerRef.current.observe(form, { childList: true, subtree: true });\n    },\n    [\n      getFields,\n      getNodeValue,\n      handleChangeEvent,\n      removeField,\n      reset,\n      setNodeValue,\n      setNodesOrStateValue,\n      setStateRef,\n      setTouchedMaybeValidate,\n      shouldRemoveField,\n      stateRef,\n      submit,\n    ]\n  );\n\n  const registerField = useCallback<RegisterField<V>>(\n    (validateOrOptions) => (field) => {\n      if (\n        !field?.name ||\n        controlledsRef.current[field.name] ||\n        excludeFieldsRef.current[field.name]\n      )\n        return;\n\n      if (isFunction(validateOrOptions)) {\n        fieldValidatorsRef.current[field.name] = validateOrOptions;\n        return;\n      }\n\n      const { validate: validator, ...parsers } = validateOrOptions;\n\n      if (validator) fieldValidatorsRef.current[field.name] = validator;\n      fieldParsersRef.current[field.name] = parsers;\n    },\n    []\n  );\n\n  shared.set(id, {\n    shouldRemoveField,\n    defaultValuesRef,\n    initialStateRef,\n    controlledsRef,\n    fieldValidatorsRef,\n    changedFieldRef,\n    excludeFieldsRef,\n    getNodeValue,\n    getFormState,\n    setDefaultValue,\n    setTouchedMaybeValidate,\n    handleChangeEvent,\n    removeField,\n    subscribeObserver,\n    unsubscribeObserver,\n    form: registerForm,\n    field: registerField,\n    select,\n    getState,\n    setValue,\n    setTouched,\n    setDirty,\n    setError,\n    clearErrors,\n    runValidation,\n    reset,\n    submit,\n  });\n\n  useEffect(\n    () => () => {\n      if (formRef.current) {\n        const handlers = handlersRef.current as Required<Handlers>;\n\n        formRef.current.removeEventListener(\"input\", handlers.change);\n        formRef.current.removeEventListener(\"focusout\", handlers.blur);\n        formRef.current.removeEventListener(\"submit\", handlers.submit);\n        formRef.current.removeEventListener(\"reset\", handlers.reset);\n        observerRef.current?.disconnect();\n      }\n\n      shared.remove(id);\n    },\n    [id]\n  );\n\n  return {\n    form: registerForm,\n    field: registerField,\n    select,\n    getState,\n    setValue,\n    setTouched,\n    setDirty,\n    setError,\n    clearErrors,\n    runValidation,\n    reset,\n    submit,\n  };\n};\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLSelectElement =>\n  field.type === \"select-one\";\n","export default (element: HTMLElement): element is HTMLInputElement =>\n  element.tagName === \"INPUT\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"number\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"range\";\n","export default (callback: (args: any) => any): any =>\n  (\n    window.requestIdleCallback ||\n    ((cb) => {\n      const start = Date.now();\n      return setTimeout(\n        () =>\n          cb({\n            didTimeout: false,\n            timeRemaining: /* istanbul ignore next */ () =>\n              Math.max(0, 50 - (Date.now() - start)),\n          }),\n        1\n      );\n    })\n  )(callback, { timeout: 2000 });\n","import { FormMethods, FormValues } from \"./types\";\nimport { get } from \"./shared\";\nimport { invariant } from \"./utils\";\n\nexport default <V extends FormValues = FormValues>(\n  formId?: string\n): FormMethods<V> => {\n  const methods = get(formId);\n\n  invariant(\n    !methods,\n    '💡 react-cool-form > useFormMethods: You must provide the corresponding ID to \"useForm\" hook. See: https://react-cool-form.netlify.app/docs/api-reference/use-form#id'\n  );\n\n  const {\n    form,\n    field,\n    select,\n    getState,\n    setValue,\n    setTouched,\n    setDirty,\n    setError,\n    clearErrors,\n    runValidation,\n    reset,\n    submit,\n  } = methods;\n\n  return {\n    form,\n    field,\n    select,\n    getState,\n    setValue,\n    setTouched,\n    setDirty,\n    setError,\n    clearErrors,\n    runValidation,\n    reset,\n    submit,\n  };\n};\n"],"names":["one","has","Object","prototype","hasOwnProperty","dequal","foo","bar","ctor","len","constructor","Date","getTime","RegExp","toString","Array","length","call","keys","all","get","id","val","ref","useRef","useEffect","current","arr","reduce","obj","key","value","FileList","cloneObject","object","Event","Error","isObject","isFileList","isArray","map","filter","Boolean","deepMerge","objects","prev","forEach","prevValue","currValue","isPlainObject","undefined","filterErrors","error","touched","nextErrors","isUndefined","str","TypeError","compact","split","path","defaultValue","stringToPath","condition","message","__DEV__","isFunction","name","field","type","element","test","tagName","immutable","segs","newObject","slice","idx","nextIsNumber","Number","isNaN","unset","refObject","last","pop","target","index","splice","isEmptyObject","join","initialState","onChange","forceUpdate","useReducer","c","stateRef","stateObserversRef","usedState","update","onChangeRef","useLatest","setStateRef","useCallback","fieldPath","shouldUpdate","state","set","errors","dirty","prevIsDirty","isDirty","prevIsValid","isValid","prevSubmitCount","submitCount","search","dty","found","values","push","getIsDirty","some","k","startsWith","setUsedState","subscribeObserver","observer","unsubscribeObserver","o","formId","rest","methods","methodName","invariant","observerRef","getFormState","callback","validate","parse","format","errorWithTouched","props","shared","hasWarn","meta","useFormState","isTouched","shouldRemoveField","defaultValuesRef","initialStateRef","controlledsRef","fieldValidatorsRef","changedFieldRef","getNodeValue","setDefaultValue","setTouchedMaybeValidate","handleChangeEvent","removeField","onBlur","restProps","e","nativeEvent","isFieldElement","defaultValues","validateOnChange","validateOnBlur","builtInValidationMode","excludeFields","onReset","onSubmit","onError","debug","handlersRef","formRef","fieldsRef","fieldParsersRef","excludeFieldsRef","arrayToMap","formValidatorRef","onResetRef","onSubmitRef","onErrorRef","isValidating","isSubmitting","isSubmitted","useState","handleUnset","t","n","getFields","form","from","querySelectorAll","fieldId","classList","rcfExclude","dataset","classes","exclude","find","acc","elm","isCheckboxInput","isRadioInput","options","isSelectOne","isSelectMultiple","fields","_fieldParsersRef$curr","valueAsNumber","_fieldParsersRef$curr2","valueAsDate","isNumberInput","isRangeInput","checkboxes","checkbox","checked","hasAttribute","radio","option","selected","isFileInput","files","setNodeValue","includes","setNodesOrStateValue","shouldUpdateDefaultValues","dfValues","getPath","p","helper","replace","paths","s","select","getState","setError","clearErrors","runBuiltInValidation","validationMessage","validity","runAllBuiltInValidation","runFieldValidation","async","exception","runAllFieldsValidation","promises","Promise","then","cur","runFormValidation","validateField","hasAsyncValidator","isAsyncFunction","validateFieldWithLowPriority","window","requestIdleCallback","cb","start","now","setTimeout","didTimeout","timeRemaining","Math","max","timeout","validateForm","errs","runValidation","setTouched","shouldValidate","setDirty","setDirtyIfNeeded","setValue","shouldTouched","shouldDirty","getOptions","reset","submit","preventDefault","stopPropagation","skip","nextValues","nextTouched","registerForm","el","change","_fieldParsersRef$curr3","blur","addEventListener","MutationObserver","currOptions","_fieldsRef$current$na","nextOptions","_fields$name$options","addedNodes","observe","childList","subtree","registerField","validateOrOptions","validator","parsers","handlers","removeEventListener","disconnect"],"mappings":"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"}