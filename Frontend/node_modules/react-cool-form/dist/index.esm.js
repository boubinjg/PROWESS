import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/objectWithoutPropertiesLoose';
import _extends from '@babel/runtime/helpers/extends';
import { useRef, useEffect, useReducer, useCallback } from 'react';
import { dequal } from 'dequal/lite';

var one;
var all = {};
var get$1 = function get(id) {
  return id ? all[id] : one;
};
var set$1 = function set(id, methods) {
  if (id) {
    all[id] = methods;
  } else {
    one = methods;
  }
};
var remove = function remove(id) {
  if (id) {
    delete all[id];
  } else {
    one = undefined;
  }
};

var useLatest = (function (val) {
  var ref = useRef(val);
  useEffect(function () {
    ref.current = val;
  });
  return ref;
});

var arrayToMap = (function (arr) {
  return arr.reduce(function (obj, key) {
    obj[key] = true;
    return obj;
  }, {});
});

var isFileList = (function (value) {
  return value instanceof FileList;
});

var isObject = (function (value) {
  return value !== null && typeof value === "object";
});

var cloneObject = function cloneObject(object) {
  if (object instanceof Event) throw new Error("Unable to clone event.");
  if (!isObject(object) || isFileList(object)) return object;
  if (object instanceof Date) return new Date(object.getTime());
  if (Array.isArray(object)) return object.map(function (val) {
    return cloneObject(val);
  });
  return Object.keys(object).reduce(function (obj, key) {
    obj[key] = cloneObject(object[key]);
    return obj;
  }, {});
};

var compact = (function (arr) {
  return arr.filter(Boolean);
});

var isPlainObject = (function (value) {
  return !Array.isArray(value) && !(value instanceof Date) && isObject(value);
});

var deepMerge = function deepMerge() {
  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
    objects[_key] = arguments[_key];
  }

  return objects.reduce(function (prev, obj) {
    Object.keys(obj).forEach(function (key) {
      var prevValue = prev[key];
      var currValue = obj[key];

      if (Array.isArray(prevValue) && Array.isArray(currValue)) {
        prev[key] = [].concat(prevValue, currValue);
      } else if (isPlainObject(prevValue) && isPlainObject(currValue)) {
        prev[key] = deepMerge(prevValue, currValue);
      } else {
        prev[key] = currValue;
      }
    });
    return prev;
  }, {});
};

var isUndefined = (function (value) {
  return value === undefined;
});

var filterErrors = function filterErrors(error, touched) {
  if (!isPlainObject(error)) return touched ? error : undefined;
  return Object.keys(error).reduce(function (obj, key) {
    var nextErrors = filterErrors(error[key], touched[key] || false);

    if (!isUndefined(nextErrors)) {
      obj[key] = nextErrors;
    } else {
      delete obj[key];
    }

    return obj;
  }, {});
};

var stringToPath = (function (str) {
  if (typeof str !== "string") throw new TypeError("Expected a string.");
  if (!str.length) return [];
  return compact(str.split(/[.[\]]+/));
});

var get = (function (object, path, defaultValue) {
  if (!isPlainObject(object) || !path) return defaultValue;
  var value = stringToPath(path).reduce(function (obj, key) {
    return (obj || {})[key];
  }, object);
  return !isUndefined(value) ? value : defaultValue;
});

var getIsDirty = function getIsDirty(dirty) {
  var search = function search(dty, found) {
    if (found === void 0) {
      found = [];
    }

    for (var _i = 0, _Object$values = Object.values(dty); _i < _Object$values.length; _i++) {
      var val = _Object$values[_i];

      if (val === true) {
        found.push(val);
        return found;
      }

      if (isObject(val)) search(val, found);
    }

    return found;
  };

  return !!search(dirty).length;
};

var invariant = (function (condition, message) {
  if (process.env.NODE_ENV !== "production" && condition) throw new Error(message);
});

var isFunction = (function (value) {
  return typeof value === "function";
});

var isAsyncFunction = (function (value) {
  return isFunction(value) && value.constructor.name === "AsyncFunction";
});

var isCheckboxInput = (function (field) {
  return field.type === "checkbox";
});

var isEmptyObject = (function (value) {
  return isPlainObject(value) && !Object.keys(value).length;
});

var isFieldElement = (function (element) {
  return /INPUT|TEXTAREA|SELECT/.test(element.tagName);
});

var isFileInput = (function (field) {
  return field.type === "file";
});

var isInputElement = (function (element) {
  return element.tagName === "INPUT";
});

var isNumberInput = (function (field) {
  return field.type === "number";
});

var isRadioInput = (function (field) {
  return field.type === "radio";
});

var isRangeInput = (function (field) {
  return field.type === "range";
});

var isSelectMultiple = (function (field) {
  return field.type === "select-multiple";
});

var isSelectOne = (function (field) {
  return field.type === "select-one";
});

var runWithLowPriority = (function (callback) {
  return (window.requestIdleCallback || function (cb) {
    var start = Date.now();
    return setTimeout(function () {
      return cb({
        didTimeout: false,
        timeRemaining:
        /* istanbul ignore next */
        function timeRemaining() {
          return Math.max(0, 50 - (Date.now() - start));
        }
      });
    }, 1);
  })(callback, {
    timeout: 2000
  });
});

var set = (function (object, path, value, immutable) {
  if (immutable === void 0) {
    immutable = false;
  }

  if (!isPlainObject(object)) throw new TypeError("Expected an object.");
  var segs = stringToPath(path);
  var newObject = immutable ? cloneObject(object) : object;
  segs.slice(0, -1).reduce(function (obj, key, idx) {
    var nextIsNumber = !Number.isNaN(+segs[idx + 1]);
    if (isPlainObject(obj[key]) && !nextIsNumber || Array.isArray(obj[key]) && nextIsNumber) return obj[key];
    obj[key] = nextIsNumber ? [] : {};
    return obj[key];
  }, newObject)[segs[segs.length - 1] || ""] = value;
  return newObject;
});

/* eslint-disable no-prototype-builtins */

var unset = function unset(object, path, immutable) {
  if (immutable === void 0) {
    immutable = false;
  }

  if (!isPlainObject(object)) throw new TypeError("Expected an object.");
  var refObject = immutable ? cloneObject(object) : object;
  var newObject = refObject;

  if (newObject.hasOwnProperty(path)) {
    delete newObject[path];
    return refObject;
  }

  var segs = stringToPath(path);
  if (!segs.length) return refObject;
  var last = segs.pop();
  var target = segs.reduce(function (obj, key) {
    return (obj || {})[key];
  }, newObject);

  if (Array.isArray(target)) {
    var index = +last;

    if (index < target.length - 1) {
      target.splice(index, 1);
    } else {
      while (index >= 0) {
        // @ts-expect-error
        if (index == last || isUndefined(target[index])) {
          target.splice(index, 1);
          index -= 1;
        } else {
          break;
        }
      }
    }
  } else if (isPlainObject(target)) {
    delete target[last];
  }

  return isEmptyObject(target) || Array.isArray(target) && !target.length ? unset(refObject, segs.join(".")) : refObject;
};

var warn = (function () {
  var _console;

  if (process.env.NODE_ENV !== "production") (_console = console).warn.apply(_console, arguments);
});

var useState = (function (initialState, onChange) {
  var _useReducer = useReducer(function (c) {
    return c + 1;
  }, 0),
      forceUpdate = _useReducer[1];

  var stateRef = useRef(initialState);
  var stateObserversRef = useRef([{
    usedState: {},
    update: forceUpdate
  }]);
  var onChangeRef = useLatest(onChange || function () {
    return undefined;
  });
  var setStateRef = useCallback(function (path, value, _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        fieldPath = _ref.fieldPath,
        _ref$shouldUpdate = _ref.shouldUpdate,
        shouldUpdate = _ref$shouldUpdate === void 0 ? true : _ref$shouldUpdate;

    var key = path.split(".")[0];

    if (!key) {
      if (!dequal(stateRef.current, value)) {
        stateRef.current = value;
        onChangeRef.current(stateRef.current);
        stateObserversRef.current.forEach(function (_ref2) {
          var usedState = _ref2.usedState,
              update = _ref2.update;
          if (shouldUpdate && !isEmptyObject(usedState)) update();
        });
      }

      return;
    }

    if (path !== "values" && key === "values" || !dequal(get(stateRef.current, path), value)) {
      var state = set(stateRef.current, path, value, true);
      var errors = state.errors,
          dirty = state.dirty,
          prevIsDirty = state.isDirty,
          prevIsValid = state.isValid;
      var prevSubmitCount = state.submitCount;
      var isDirty = key === "dirty" ? getIsDirty(dirty) : prevIsDirty;
      var isValid = key === "errors" ? isEmptyObject(errors) : prevIsValid;
      var submitCount = key === "isSubmitting" && value ? prevSubmitCount += 1 : prevSubmitCount;
      stateRef.current = _extends({}, state, {
        isDirty: isDirty,
        isValid: isValid,
        submitCount: submitCount
      });
      onChangeRef.current(stateRef.current);
      if (!shouldUpdate) return;
      path = fieldPath || path;
      stateObserversRef.current.forEach(function (_ref3) {
        var usedState = _ref3.usedState,
            update = _ref3.update;
        if (Object.keys(usedState).some(function (k) {
          return path.startsWith(k) || k.startsWith(path);
        }) || usedState.isDirty && isDirty !== prevIsDirty || usedState.isValid && isValid !== prevIsValid) update();
      });
    }
  }, [onChangeRef]);
  var setUsedState = useCallback(function (usedState) {
    stateObserversRef.current[0].usedState = usedState;
  }, []);
  var subscribeObserver = useCallback(function (observer) {
    return stateObserversRef.current.push(observer);
  }, []);
  var unsubscribeObserver = useCallback(function (observer) {
    stateObserversRef.current = stateObserversRef.current.filter(function (o) {
      return o !== observer;
    });
  }, []);
  return {
    stateRef: stateRef,
    setStateRef: setStateRef,
    setUsedState: setUsedState,
    subscribeObserver: subscribeObserver,
    unsubscribeObserver: unsubscribeObserver
  };
});

var useForm = (function (_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      id = _ref.id,
      _ref$defaultValues = _ref.defaultValues,
      defaultValues = _ref$defaultValues === void 0 ? {} : _ref$defaultValues,
      validate = _ref.validate,
      _ref$validateOnChange = _ref.validateOnChange,
      validateOnChange = _ref$validateOnChange === void 0 ? true : _ref$validateOnChange,
      _ref$validateOnBlur = _ref.validateOnBlur,
      validateOnBlur = _ref$validateOnBlur === void 0 ? true : _ref$validateOnBlur,
      _ref$builtInValidatio = _ref.builtInValidationMode,
      builtInValidationMode = _ref$builtInValidatio === void 0 ? "message" : _ref$builtInValidatio,
      _ref$shouldRemoveFiel = _ref.shouldRemoveField,
      shouldRemoveField = _ref$shouldRemoveFiel === void 0 ? true : _ref$shouldRemoveFiel,
      _ref$excludeFields = _ref.excludeFields,
      excludeFields = _ref$excludeFields === void 0 ? [] : _ref$excludeFields,
      onReset = _ref.onReset,
      onSubmit = _ref.onSubmit,
      onError = _ref.onError,
      debug = _ref.debug;

  var handlersRef = useRef({});
  var observerRef = useRef();
  var formRef = useRef();
  var fieldsRef = useRef({});
  var fieldParsersRef = useRef({});
  var controlledsRef = useRef({});
  var excludeFieldsRef = useRef(arrayToMap(excludeFields));
  var changedFieldRef = useRef();
  var formValidatorRef = useLatest(validate);
  var fieldValidatorsRef = useRef({});
  var onResetRef = useLatest(onReset || function () {
    return undefined;
  });
  var onSubmitRef = useLatest(onSubmit || function () {
    return undefined;
  });
  var onErrorRef = useLatest(onError || function () {
    return undefined;
  });
  var defaultValuesRef = useRef(defaultValues);
  var initialStateRef = useRef({
    values: defaultValuesRef.current,
    touched: {},
    errors: {},
    isDirty: false,
    dirty: {},
    isValidating: false,
    isValid: true,
    isSubmitting: false,
    isSubmitted: false,
    submitCount: 0
  });

  var _useState = useState(initialStateRef.current, debug),
      stateRef = _useState.stateRef,
      setStateRef = _useState.setStateRef,
      setUsedState = _useState.setUsedState,
      subscribeObserver = _useState.subscribeObserver,
      unsubscribeObserver = _useState.unsubscribeObserver;

  var handleUnset = useCallback(function (path) {
    var _path$split = path.split("."),
        t = _path$split[0],
        n = _path$split[1];

    setStateRef(t, unset(stateRef.current[t], n, true), {
      fieldPath: path
    });
  }, [setStateRef, stateRef]);
  var getFields = useCallback(function (form) {
    return Array.from(form.querySelectorAll("input,textarea,select")).filter(function (element) {
      var field = element;
      var type = field.type,
          name = field.name,
          fieldId = field.id,
          classList = field.classList,
          rcfExclude = field.dataset.rcfExclude;
      var classes = Array.from(classList);
      var exclude = excludeFieldsRef.current;
      if (/button|image|submit|reset/.test(type) || fieldId && exclude["#" + fieldId] || classes.find(function (n) {
        return exclude["." + n];
      })) return false;

      if (rcfExclude !== "true" && !name) {
        warn('ðŸ’¡ react-cool-form > field: Missing "name" attribute. Do you want to exclude the field? See: https://react-cool-form.netlify.app/docs/api-reference/use-form/#excludefields');
        return false;
      }

      return controlledsRef.current[name] || rcfExclude !== "true" && !exclude[name];
    }).reduce(function (acc, elm) {
      var _acc$name;

      var field = elm;
      var name = field.name;
      acc[name] = _extends({}, acc[name], {
        field: ((_acc$name = acc[name]) == null ? void 0 : _acc$name.field) || field
      });

      if (isCheckboxInput(field) || isRadioInput(field)) {
        acc[name].options = acc[name].options ? [].concat(acc[name].options, [field]) : [field];
      } else if (isSelectOne(field) || isSelectMultiple(field)) {
        acc[name].options = Array.from(field.options);
      }

      return acc;
    }, {});
  }, []);
  var getNodeValue = useCallback(function (name, fields) {
    var _find;

    if (fields === void 0) {
      fields = fieldsRef.current;
    }

    var _fields$name = fields[name],
        field = _fields$name.field,
        options = _fields$name.options;
    var value = field.value;

    if (isInputElement(field)) {
      var _fieldParsersRef$curr, _fieldParsersRef$curr2;

      if ((_fieldParsersRef$curr = fieldParsersRef.current[name]) != null && _fieldParsersRef$curr.valueAsNumber) {
        value = field.valueAsNumber;
        return value;
      }

      if ((_fieldParsersRef$curr2 = fieldParsersRef.current[name]) != null && _fieldParsersRef$curr2.valueAsDate) {
        value = field.valueAsDate;
        return value;
      }
    }

    if (isNumberInput(field) || isRangeInput(field)) value = field.valueAsNumber || "";

    if (isCheckboxInput(field)) {
      var checkboxes = options;
      var checkbox = checkboxes[0];

      if (checkboxes.length > 1) {
        value = checkboxes.filter(function (c) {
          return c.checked;
        }).map(function (c) {
          return c.value;
        });
      } else if (checkbox.hasAttribute("value") && checkbox.value) {
        value = checkbox.checked ? [checkbox.value] : [];
      } else {
        value = checkbox.checked;
      }
    }

    if (isRadioInput(field)) value = ((_find = options.find(function (radio) {
      return radio.checked;
    })) == null ? void 0 : _find.value) || "";
    if (isSelectMultiple(field)) value = options.filter(function (option) {
      return option.selected;
    }).map(function (option) {
      return option.value;
    });
    if (isFileInput(field)) value = field.files;
    return value;
  }, []);
  var setNodeValue = useCallback(function (name, value, fields) {
    if (fields === void 0) {
      fields = fieldsRef.current;
    }

    if (!fields[name] || controlledsRef.current[name]) return;
    var _fields$name2 = fields[name],
        field = _fields$name2.field,
        options = _fields$name2.options;

    if (isCheckboxInput(field)) {
      var checkboxes = options;

      if (checkboxes.length > 1) {
        checkboxes.forEach(function (checkbox) {
          checkbox.checked = Array.isArray(value) ? value.includes(checkbox.value) : !!value;
        });
      } else {
        checkboxes[0].checked = !!value;
      }
    } else if (isRadioInput(field)) {
      options.forEach(function (radio) {
        radio.checked = radio.value === value;
      });
    } else if (isSelectMultiple(field) && Array.isArray(value)) {
      options.forEach(function (option) {
        option.selected = !!value.includes(option.value);
      });
    } else if (isFileInput(field)) {
      if (isFileList(value)) field.files = value;
      if (!value) field.value = "";
    } else {
      field.value = value != null ? value : "";
    }
  }, []);
  var setDefaultValue = useCallback(function (name, value) {
    initialStateRef.current = set(initialStateRef.current, "values." + name, value, true);
    setStateRef("values." + name, value, {
      shouldUpdate: false
    });
  }, [setStateRef]);
  var setNodesOrStateValue = useCallback(function (values, _temp2) {
    var _ref2 = _temp2 === void 0 ? {} : _temp2,
        _ref2$shouldUpdateDef = _ref2.shouldUpdateDefaultValues,
        shouldUpdateDefaultValues = _ref2$shouldUpdateDef === void 0 ? true : _ref2$shouldUpdateDef,
        _ref2$fields = _ref2.fields,
        fields = _ref2$fields === void 0 ? Object.values(fieldsRef.current) : _ref2$fields;

    return fields.forEach(function (field) {
      var name = isPlainObject(field) ? field.field.name : field;
      if (controlledsRef.current[name]) return;
      var value = get(values, name);
      if (!isUndefined(value)) setNodeValue(name, value);

      if (shouldUpdateDefaultValues) {
        value = get(defaultValuesRef.current, name);
        setDefaultValue(name, !isUndefined(value) ? value : getNodeValue(name));
      }
    });
  }, [getNodeValue, setDefaultValue, setNodeValue]);
  var getFormState = useCallback(function (path, _ref3) {
    var target = _ref3.target,
        errorWithTouched = _ref3.errorWithTouched,
        _ref3$defaultValues = _ref3.defaultValues,
        dfValues = _ref3$defaultValues === void 0 ? {} : _ref3$defaultValues,
        _ref3$methodName = _ref3.methodName,
        methodName = _ref3$methodName === void 0 ? "select" : _ref3$methodName,
        callback = _ref3.callback;
    if (!path) return callback ? undefined : stateRef.current;
    var usedState = {};

    var getPath = function getPath(p) {
      p = target ? target + "." + p : p;

      if (callback) {
        if (p === "values") warn("\uD83D\uDCA1 react-cool-form > " + methodName + ": Getting \"values\" alone might cause unnecessary re-renders. If you know what you're doing, please ignore this warning. See: https://react-cool-form.netlify.app/docs/getting-started/form-state#best-practices");
        usedState[p] = true;
      }

      return p;
    };

    var helper = function helper(p, state) {
      if (p.startsWith("values")) {
        if (!isUndefined(state)) return state;
        p = p.replace("values.", "");
        state = get(defaultValuesRef.current, p);
        return !isUndefined(state) ? state : get(dfValues, p);
      }

      if (!errorWithTouched || !p.startsWith("errors") || !state || isEmptyObject(state)) return state;
      p = p.replace("errors", "touched");
      usedState[p] = true;
      return filterErrors(state, get(stateRef.current, p));
    };

    var state;

    if (Array.isArray(path)) {
      state = path.map(function (p) {
        p = getPath(p);
        return helper(p, get(stateRef.current, p));
      });
    } else if (isPlainObject(path)) {
      var paths = path;
      state = Object.keys(paths).reduce(function (s, key) {
        path = getPath(paths[key]);
        s[key] = helper(path, get(stateRef.current, path));
        return s;
      }, {});
    } else {
      path = getPath(path);
      state = helper(path, get(stateRef.current, path));
    }

    if (callback) callback(usedState);
    return state;
  }, [stateRef]);
  var select = useCallback(function (path, _temp3) {
    var _ref4 = _temp3 === void 0 ? {} : _temp3,
        target = _ref4.target,
        errorWithTouched = _ref4.errorWithTouched,
        dfValues = _ref4.defaultValues;

    return getFormState(path, {
      target: target,
      errorWithTouched: errorWithTouched,
      defaultValues: dfValues,
      callback: function callback(usedState) {
        return setUsedState(usedState);
      }
    });
  }, [getFormState, setUsedState]);
  var getState = useCallback(function (path, target) {
    return getFormState(path, {
      target: target
    });
  }, [getFormState]);
  var setError = useCallback(function (name, error) {
    error = isFunction(error) ? error(get(stateRef.current.errors, name)) : error;

    if (error) {
      setStateRef("errors." + name, error);
    } else {
      handleUnset("errors." + name);
    }
  }, [handleUnset, setStateRef, stateRef]);
  var clearErrors = useCallback(function (name) {
    if (!name) {
      setStateRef("errors", {});
    } else if (Array.isArray(name)) {
      name.forEach(function (n) {
        return setError(n);
      });
    } else {
      setError(name);
    }
  }, [setError, setStateRef]);
  var runBuiltInValidation = useCallback(function (name) {
    if (builtInValidationMode === false || !fieldsRef.current[name]) return undefined;
    var field = fieldsRef.current[name].field;
    if (builtInValidationMode === "message") return field.validationMessage;

    for (var k in field.validity) {
      // @ts-expect-error
      if (k !== "valid" && field.validity[k]) return k;
    }

    return undefined;
  }, [builtInValidationMode]);
  var runAllBuiltInValidation = useCallback(function () {
    if (builtInValidationMode === false) return {};
    return Object.keys(fieldsRef.current).reduce(function (errors, name) {
      var error = runBuiltInValidation(name);
      errors = _extends({}, errors, error ? set({}, name, error) : {});
      return errors;
    }, {});
  }, [builtInValidationMode, runBuiltInValidation]);
  var runFieldValidation = useCallback(async function (name) {
    if (!fieldValidatorsRef.current[name]) return undefined;

    try {
      var error = await fieldValidatorsRef.current[name](get(stateRef.current.values, name), stateRef.current.values);
      return error;
    } catch (exception) {
      warn("\uD83D\uDCA1 react-cool-form > validate " + name + ": ", exception);
      throw exception;
    }
  }, [stateRef]);
  var runAllFieldsValidation = useCallback(function () {
    var promises = Object.keys(fieldValidatorsRef.current).map(function (name) {
      return runFieldValidation(name);
    });
    return Promise.all(promises).then(function (errors) {
      return Object.keys(fieldValidatorsRef.current).reduce(function (acc, cur, idx) {
        acc = _extends({}, acc, errors[idx] ? set({}, cur, errors[idx]) : {});
        return acc;
      }, {});
    });
  }, [runFieldValidation]);
  var runFormValidation = useCallback(async function (name) {
    if (!formValidatorRef.current) return name ? undefined : {};

    try {
      var errors = await formValidatorRef.current(stateRef.current.values);
      if (name) return get(errors, name);
      return isPlainObject(errors) ? errors : {};
    } catch (exception) {
      warn("\uD83D\uDCA1 react-cool-form > validate form: ", exception);
      throw exception;
    }
  }, [formValidatorRef, stateRef]);
  var validateField = useCallback(async function (name) {
    var hasAsyncValidator = isAsyncFunction(formValidatorRef.current) || isAsyncFunction(fieldValidatorsRef.current[name]);
    if (hasAsyncValidator) setStateRef("isValidating", true);

    try {
      var error = (await runFormValidation(name)) || (await runFieldValidation(name)) || runBuiltInValidation(name);
      setError(name, error);
      if (hasAsyncValidator) setStateRef("isValidating", false);
      return error;
    } catch (exception) {
      return exception;
    }
  }, [formValidatorRef, runBuiltInValidation, runFieldValidation, runFormValidation, setError, setStateRef]);
  var validateFieldWithLowPriority = useCallback(function (name) {
    return runWithLowPriority(function () {
      return validateField(name);
    });
  }, [validateField]);
  var validateForm = useCallback(function () {
    setStateRef("isValidating", true);
    return Promise.all([runAllBuiltInValidation(), runAllFieldsValidation(), runFormValidation()]).then(function (errors) {
      var errs = deepMerge.apply(void 0, errors);
      setStateRef("errors", errs);
      setStateRef("isValidating", false);
      return errs;
    });
  }, [runAllBuiltInValidation, runAllFieldsValidation, runFormValidation, setStateRef]);
  var runValidation = useCallback(function (name) {
    if (!name) return validateForm().then(function (errors) {
      return isEmptyObject(errors);
    });
    if (Array.isArray(name)) return Promise.all(name.map(function (n) {
      return validateField(n);
    })).then(function (errors) {
      return !compact(errors).length;
    });
    return validateField(name).then(function (error) {
      return !error;
    });
  }, [validateField, validateForm]);
  var setTouched = useCallback(function (name, isTouched, shouldValidate) {
    if (isTouched === void 0) {
      isTouched = true;
    }

    if (shouldValidate === void 0) {
      shouldValidate = validateOnBlur;
    }

    if (isTouched) {
      setStateRef("touched." + name, true);
    } else {
      handleUnset("touched." + name);
    }

    if (shouldValidate) validateFieldWithLowPriority(name);
  }, [handleUnset, setStateRef, validateFieldWithLowPriority, validateOnBlur]);
  var setTouchedMaybeValidate = useCallback(function (name) {
    return setTouched(name, true, validateOnChange ? name !== changedFieldRef.current : undefined);
  }, [setTouched, validateOnChange]);
  var setDirty = useCallback(function (name, isDirty) {
    if (isDirty === void 0) {
      isDirty = true;
    }

    if (isDirty) {
      setStateRef("dirty." + name, true);
    } else {
      handleUnset("dirty." + name);
    }
  }, [handleUnset, setStateRef]);
  var setDirtyIfNeeded = useCallback(function (name) {
    return setDirty(name, !dequal(get(stateRef.current.values, name), get(initialStateRef.current.values, name)));
  }, [setDirty, stateRef]);
  var setValue = useCallback(function (name, value, _temp4) {
    var _ref5 = _temp4 === void 0 ? {} : _temp4,
        _ref5$shouldValidate = _ref5.shouldValidate,
        shouldValidate = _ref5$shouldValidate === void 0 ? validateOnChange : _ref5$shouldValidate,
        _ref5$shouldTouched = _ref5.shouldTouched,
        shouldTouched = _ref5$shouldTouched === void 0 ? true : _ref5$shouldTouched,
        _ref5$shouldDirty = _ref5.shouldDirty,
        shouldDirty = _ref5$shouldDirty === void 0 ? true : _ref5$shouldDirty;

    value = isFunction(value) ? value(get(stateRef.current.values, name)) : value;

    if (!isUndefined(value)) {
      setStateRef("values." + name, value);
    } else {
      handleUnset("values." + name);
    }

    setNodeValue(name, value);
    if (shouldTouched) setTouched(name, true, false);
    if (shouldDirty) setDirtyIfNeeded(name);
    if (shouldValidate) validateFieldWithLowPriority(name);
  }, [handleUnset, setDirtyIfNeeded, setNodeValue, setStateRef, setTouched, stateRef, validateFieldWithLowPriority, validateOnChange]);
  var getOptions = useCallback(function () {
    return {
      getState: getState,
      setValue: setValue,
      setTouched: setTouched,
      setDirty: setDirty,
      setError: setError,
      clearErrors: clearErrors,
      runValidation: runValidation,
      reset: reset,
      submit: submit
    };
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  []);
  var reset = useCallback(function (values, exclude, e) {
    if (e != null && e.preventDefault) e.preventDefault();
    if (e != null && e.stopPropagation) e.stopPropagation();

    var state = _extends({}, stateRef.current);

    var skip = arrayToMap(exclude || []);
    Object.keys(state).forEach(function (key) {
      if (skip[key]) return;

      if (key === "values") {
        var nextValues = (isFunction(values) ? values(stateRef.current.values) : values) || initialStateRef.current.values;
        state[key] = nextValues;
        initialStateRef.current = set(initialStateRef.current, "values", nextValues, true);
        setNodesOrStateValue(nextValues, {
          shouldUpdateDefaultValues: false
        });
      } else {
        // @ts-expect-error
        state[key] = initialStateRef.current[key];
      }
    });
    setStateRef("", state);
    onResetRef.current(state.values, getOptions(), e);
  }, [getOptions, onResetRef, setNodesOrStateValue, setStateRef, stateRef]);
  var submit = useCallback(async function (e) {
    if (e != null && e.preventDefault) e.preventDefault();
    if (e != null && e.stopPropagation) e.stopPropagation();
    var nextTouched = Object.keys(_extends({}, fieldsRef.current, controlledsRef.current)).reduce(function (touched, name) {
      touched = set(touched, name, true, true);
      return touched;
    }, stateRef.current.touched);
    setStateRef("touched", nextTouched);
    setStateRef("isSubmitting", true);

    try {
      var errors = await validateForm();

      if (!isEmptyObject(errors)) {
        onErrorRef.current(errors, getOptions(), e);
        return {
          errors: errors
        };
      }

      await onSubmitRef.current(stateRef.current.values, getOptions(), e);
      setStateRef("isSubmitted", true);
      return {
        values: stateRef.current.values
      };
    } catch (exception) {
      warn("\uD83D\uDCA1 react-cool-form > submit: ", exception);
      throw exception;
    } finally {
      setStateRef("isSubmitting", false);
    }
  }, [getOptions, onErrorRef, onSubmitRef, setStateRef, stateRef, validateForm]);
  var handleChangeEvent = useCallback(function (name, value) {
    setStateRef("values." + name, value);
    setDirtyIfNeeded(name);
    if (validateOnChange) validateFieldWithLowPriority(name);
  }, [setDirtyIfNeeded, setStateRef, validateFieldWithLowPriority, validateOnChange]);
  var removeField = useCallback(function (name) {
    handleUnset("values." + name);
    handleUnset("touched." + name);
    handleUnset("dirty." + name);
    handleUnset("errors." + name);
    initialStateRef.current = unset(initialStateRef.current, "values." + name, true);
    delete fieldParsersRef.current[name];
    delete fieldValidatorsRef.current[name];
    delete controlledsRef.current[name];
  }, [handleUnset]);
  var registerForm = useCallback(function (el) {
    if (!el) return;
    formRef.current = el;
    var form = formRef.current;
    fieldsRef.current = getFields(form);
    setNodesOrStateValue(initialStateRef.current.values);

    handlersRef.current.change = function (_ref6) {
      var target = _ref6.target;
      var _ref7 = target,
          name = _ref7.name;

      if (!name) {
        warn('ðŸ’¡ react-cool-form > field: Missing "name" attribute.');
        return;
      }

      if (fieldsRef.current[name] && !controlledsRef.current[name]) {
        var _fieldParsersRef$curr3;

        var parse = (_fieldParsersRef$curr3 = fieldParsersRef.current[name]) == null ? void 0 : _fieldParsersRef$curr3.parse;
        var value = getNodeValue(name);
        handleChangeEvent(name, parse ? parse(value) : value);
        changedFieldRef.current = name;
      }
    };

    handlersRef.current.blur = function (_ref8) {
      var target = _ref8.target;
      if (!isFieldElement(target)) return;
      var _ref9 = target,
          name = _ref9.name;

      if (fieldsRef.current[name] && !controlledsRef.current[name]) {
        setTouchedMaybeValidate(name);
        changedFieldRef.current = undefined;
      }
    };

    handlersRef.current.submit = function (e) {
      return submit(e);
    };

    handlersRef.current.reset = function (e) {
      return reset(null, null, e);
    };

    form.addEventListener("input", handlersRef.current.change);
    form.addEventListener("focusout", handlersRef.current.blur);
    form.addEventListener("submit", handlersRef.current.submit);
    form.addEventListener("reset", handlersRef.current.reset);
    observerRef.current = new MutationObserver(function (_ref10) {
      var type = _ref10[0].type;
      if (type !== "childList") return;
      var fields = getFields(form);
      if (shouldRemoveField) Object.keys(fieldsRef.current).forEach(function (name) {
        var _fieldsRef$current$na, _fields$name$options;

        if (controlledsRef.current[name]) return;

        if (!fields[name]) {
          removeField(name);
          return;
        }

        var currOptions = (_fieldsRef$current$na = fieldsRef.current[name].options) == null ? void 0 : _fieldsRef$current$na.length;
        var nextOptions = (_fields$name$options = fields[name].options) == null ? void 0 : _fields$name$options.length;

        if (currOptions > nextOptions) {
          setStateRef("values." + name, getNodeValue(name, fields), {
            shouldUpdate: false
          });
        } else if (currOptions < nextOptions) {
          setNodeValue(name, get(initialStateRef.current.values, name), fields);
        }
      });
      var values = defaultValuesRef.current;
      var addedNodes = [];
      Object.keys(fields).forEach(function (name) {
        if (fieldsRef.current[name] || controlledsRef.current[name]) return;
        var value = get(stateRef.current.values, name);
        if (!isUndefined(value)) values = set(values, name, value, true);
        addedNodes.push(name);
      });
      fieldsRef.current = fields;
      if (addedNodes.length) setNodesOrStateValue(values, {
        fields: addedNodes
      });
    });
    observerRef.current.observe(form, {
      childList: true,
      subtree: true
    });
  }, [getFields, getNodeValue, handleChangeEvent, removeField, reset, setNodeValue, setNodesOrStateValue, setStateRef, setTouchedMaybeValidate, shouldRemoveField, stateRef, submit]);
  var registerField = useCallback(function (validateOrOptions) {
    return function (field) {
      if (!(field != null && field.name) || controlledsRef.current[field.name] || excludeFieldsRef.current[field.name]) return;

      if (isFunction(validateOrOptions)) {
        fieldValidatorsRef.current[field.name] = validateOrOptions;
        return;
      }

      var validator = validateOrOptions.validate,
          parsers = _objectWithoutPropertiesLoose(validateOrOptions, ["validate"]);

      if (validator) fieldValidatorsRef.current[field.name] = validator;
      fieldParsersRef.current[field.name] = parsers;
    };
  }, []);
  set$1(id, {
    shouldRemoveField: shouldRemoveField,
    defaultValuesRef: defaultValuesRef,
    initialStateRef: initialStateRef,
    controlledsRef: controlledsRef,
    fieldValidatorsRef: fieldValidatorsRef,
    changedFieldRef: changedFieldRef,
    excludeFieldsRef: excludeFieldsRef,
    getNodeValue: getNodeValue,
    getFormState: getFormState,
    setDefaultValue: setDefaultValue,
    setTouchedMaybeValidate: setTouchedMaybeValidate,
    handleChangeEvent: handleChangeEvent,
    removeField: removeField,
    subscribeObserver: subscribeObserver,
    unsubscribeObserver: unsubscribeObserver,
    form: registerForm,
    field: registerField,
    select: select,
    getState: getState,
    setValue: setValue,
    setTouched: setTouched,
    setDirty: setDirty,
    setError: setError,
    clearErrors: clearErrors,
    runValidation: runValidation,
    reset: reset,
    submit: submit
  });
  useEffect(function () {
    return function () {
      if (formRef.current) {
        var _observerRef$current;

        var handlers = handlersRef.current;
        formRef.current.removeEventListener("input", handlers.change);
        formRef.current.removeEventListener("focusout", handlers.blur);
        formRef.current.removeEventListener("submit", handlers.submit);
        formRef.current.removeEventListener("reset", handlers.reset);
        (_observerRef$current = observerRef.current) == null ? void 0 : _observerRef$current.disconnect();
      }

      remove(id);
    };
  }, [id]);
  return {
    form: registerForm,
    field: registerField,
    select: select,
    getState: getState,
    setValue: setValue,
    setTouched: setTouched,
    setDirty: setDirty,
    setError: setError,
    clearErrors: clearErrors,
    runValidation: runValidation,
    reset: reset,
    submit: submit
  };
});

var useFormMethods = (function (formId) {
  var methods = get$1(formId);
  invariant(!methods, 'ðŸ’¡ react-cool-form > useFormMethods: You must provide the corresponding ID to "useForm" hook. See: https://react-cool-form.netlify.app/docs/api-reference/use-form#id');
  var form = methods.form,
      field = methods.field,
      select = methods.select,
      getState = methods.getState,
      setValue = methods.setValue,
      setTouched = methods.setTouched,
      setDirty = methods.setDirty,
      setError = methods.setError,
      clearErrors = methods.clearErrors,
      runValidation = methods.runValidation,
      reset = methods.reset,
      submit = methods.submit;
  return {
    form: form,
    field: field,
    select: select,
    getState: getState,
    setValue: setValue,
    setTouched: setTouched,
    setDirty: setDirty,
    setError: setError,
    clearErrors: clearErrors,
    runValidation: runValidation,
    reset: reset,
    submit: submit
  };
});

var useFormState = (function (path, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      formId = _ref.formId,
      rest = _objectWithoutPropertiesLoose(_ref, ["formId"]);

  var methods = get$1(formId);
  var methodName = "useFormState";
  invariant(!methods, "\uD83D\uDCA1 react-cool-form > " + methodName + ": You must provide the corresponding ID to \"useForm\" hook. See: https://react-cool-form.netlify.app/docs/api-reference/use-form#id");
  var observerRef = useRef();

  var _useReducer = useReducer(function (c) {
    return c + 1;
  }, 0),
      forceUpdate = _useReducer[1];

  var getFormState = methods.getFormState,
      subscribeObserver = methods.subscribeObserver,
      unsubscribeObserver = methods.unsubscribeObserver;
  useEffect(function () {
    // @ts-expect-error
    subscribeObserver(observerRef.current); // @ts-expect-error

    return function () {
      return unsubscribeObserver(observerRef.current);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  return getFormState(path, _extends({}, rest, {
    methodName: methodName,
    callback: function callback(usedState) {
      if (!observerRef.current) observerRef.current = {
        usedState: usedState,
        update: forceUpdate
      };
    }
  }));
});

var useControlled = (function (name, _temp) {
  var _ref2;

  var _ref = _temp === void 0 ? {} : _temp,
      formId = _ref.formId,
      defaultValue = _ref.defaultValue,
      validate = _ref.validate,
      parse = _ref.parse,
      format = _ref.format,
      errorWithTouched = _ref.errorWithTouched,
      props = _objectWithoutPropertiesLoose(_ref, ["formId", "defaultValue", "validate", "parse", "format", "errorWithTouched"]);

  invariant(!name, 'ðŸ’¡ react-cool-form > useControlled: Missing "name" parameter.');
  var methods = get$1(formId);
  invariant(!methods, 'ðŸ’¡ react-cool-form > useControlled: You must provide the corresponding ID to "useForm" hook. See: https://react-cool-form.netlify.app/docs/api-reference/use-form#id');
  var hasWarn = useRef(false);
  var meta = useFormState({
    value: "values." + name,
    error: "errors." + name,
    isTouched: "touched." + name,
    isDirty: "dirty." + name
  }, {
    formId: formId,
    errorWithTouched: errorWithTouched
  });
  var shouldRemoveField = methods.shouldRemoveField,
      defaultValuesRef = methods.defaultValuesRef,
      initialStateRef = methods.initialStateRef,
      controlledsRef = methods.controlledsRef,
      fieldValidatorsRef = methods.fieldValidatorsRef,
      changedFieldRef = methods.changedFieldRef,
      getNodeValue = methods.getNodeValue,
      setDefaultValue = methods.setDefaultValue,
      setTouchedMaybeValidate = methods.setTouchedMaybeValidate,
      handleChangeEvent = methods.handleChangeEvent,
      removeField = methods.removeField;
  useEffect(function () {
    return function () {
      if (shouldRemoveField) removeField(name);
    };
  }, [name, removeField, shouldRemoveField]);
  controlledsRef.current[name] = true;
  if (validate) fieldValidatorsRef.current[name] = validate;
  var value;

  if (isUndefined(get(initialStateRef.current.values, name))) {
    value = get(defaultValuesRef.current, name);
    value = !isUndefined(value) ? value : defaultValue;

    if (!isUndefined(value)) {
      setDefaultValue(name, value);
    } else if (!hasWarn.current) {
      warn("\uD83D\uDCA1 react-cool-form > useControlled: Please provide a default value for \"" + name + "\" field.");
      hasWarn.current = true;
    }
  }

  value = !isUndefined(meta.value) ? meta.value : value;
  value = (_ref2 = format ? format(value) : value) != null ? _ref2 : "";

  var _onChange = props.onChange,
      _onBlur = props.onBlur,
      restProps = _objectWithoutPropertiesLoose(props, ["onChange", "onBlur"]);

  return [_extends({
    name: name,
    value: value,
    onChange: function onChange() {
      var val;

      if (parse) {
        val = parse.apply(void 0, arguments);
      } else {
        var e = arguments.length <= 0 ? undefined : arguments[0];
        val = (e == null ? void 0 : e.nativeEvent) instanceof Event && isFieldElement(e.target) ? getNodeValue(name) : e;
      }

      handleChangeEvent(name, val);
      if (_onChange) _onChange.apply(void 0, arguments);
      changedFieldRef.current = name;
    },
    onBlur: function onBlur(e) {
      setTouchedMaybeValidate(name);
      if (_onBlur) _onBlur(e);
      changedFieldRef.current = undefined;
    }
  }, restProps), {
    error: meta.error,
    isTouched: !!meta.isTouched,
    isDirty: !!meta.isDirty
  }];
});

export { get, set, unset, useControlled, useForm, useFormMethods, useFormState };
//# sourceMappingURL=index.esm.js.map
