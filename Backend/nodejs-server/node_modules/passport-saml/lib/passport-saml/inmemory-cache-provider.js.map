{"version":3,"file":"inmemory-cache-provider.js","sourceRoot":"","sources":["../../src/passport-saml/inmemory-cache-provider.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;GAaG;;;AAWH,MAAa,aAAa;IAItB,YAAY,OAAsC;QAC9C,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;QAEpB,IAAI,CAAC,OAAO,EAAE;YACV,OAAO,GAAG,EAAE,CAAC;SAChB;QAED,IAAG,CAAC,OAAO,CAAC,qBAAqB,EAAC;YAC9B,OAAO,CAAC,qBAAqB,GAAG,QAAQ,CAAC,CAAE,UAAU;SACxD;QAED,IAAI,CAAC,OAAO,GAAG,OAA+B,CAAC;QAE/C,wBAAwB;QACxB,MAAM,eAAe,GAAG,WAAW,CAAC,GAAG,EAAE;YACrC,MAAM,KAAK,GAAG,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE,CAAC;YACnC,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YACzC,IAAI,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,EAAE;gBACjB,IAAG,KAAK,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,SAAS,CAAC,CAAC,OAAO,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,qBAAqB,EAAC;oBAC/F,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC,SAAS,CAAC,CAAC;iBACrC;YACL,CAAC,CAAC,CAAC;QACP,CAAC,EAAE,IAAI,CAAC,OAAO,CAAC,qBAAqB,CAAC,CAAC;QAEvC,wGAAwG;QACxG,qEAAqE;QACrE,yEAAyE;QACzE,IAAI,eAAe,CAAC,KAAK,IAAI,OAAO,CAAC,OAAO,KAAK,UAAU;YACvD,eAAe,CAAC,KAAK,EAAE,CAAC;IAChC,CAAC;IAED;;;;;OAKG;IACH,IAAI,CAAC,GAAW,EAAE,KAAa,EAAE,QAAwD;QACrF,IAAG,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EACvB;YACI,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG;gBAClB,SAAS,EAAE,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE;gBAC/B,KAAK,EAAE,KAAK;aACf,CAAC;YAEF,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC;SACvC;aAED;YACI,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;SACxB;IAEL,CAAC;IAGD;;;;OAIG;IACH,GAAG,CAAC,GAAW,EAAE,QAA4D;QACzE,IAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAC;YACnB,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC;SAC7C;aAED;YACI,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;SACxB;IAEL,CAAC;IAGD;;;OAGG;IACH,MAAM,CAAC,GAAW,EAAE,QAAyD;QACzE,IAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EACtB;YACI,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;YAC3B,QAAQ,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;SACvB;aAED;YACI,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;SACxB;IAEL,CAAC;CACJ;AA5FD,sCA4FC","sourcesContent":["/**\n * Simple in memory cache provider.  To be used to store state of requests that needs\n * to be validated/checked when a response is received.\n *\n * This is the default implementation of a cache provider used by Passport-SAML.  For\n * multiple server instances/load balanced scenarios (I.e. the SAML request could have\n * been generated from a different server/process handling the SAML response) this\n * implementation will NOT be sufficient.\n *\n * The caller should provide their own implementation for a cache provider as defined\n * in the config options for Passport-SAML.\n * @param options\n * @constructor\n */\n\nexport interface CacheItem {\n    value: string;\n    createdAt: number;\n}\n\ninterface CacheProviderOptions {\n    keyExpirationPeriodMs: number;\n}\n\nexport class CacheProvider {\n    cacheKeys: Record<string, CacheItem>;\n    options: CacheProviderOptions;\n\n    constructor(options: Partial<CacheProviderOptions>) {\n        this.cacheKeys = {};\n\n        if (!options) {\n            options = {};\n        }\n\n        if(!options.keyExpirationPeriodMs){\n            options.keyExpirationPeriodMs = 28800000;  // 8 hours\n        }\n\n        this.options = options as CacheProviderOptions;\n\n        // Expire old cache keys\n        const expirationTimer = setInterval(() => {\n            const nowMs = new Date().getTime();\n            const keys = Object.keys(this.cacheKeys);\n            keys.forEach((key) => {\n                if(nowMs >= new Date(this.cacheKeys[key].createdAt).getTime() + this.options.keyExpirationPeriodMs){\n                    this.remove(key, () => undefined);\n                }\n            });\n        }, this.options.keyExpirationPeriodMs);\n\n        // we only want this to run if the process is still open; it shouldn't hold the process open (issue #68)\n        //   (unref only introduced in node 0.9, so check whether we have it)\n        // Skip this in 0.10.34 due to https://github.com/joyent/node/issues/8900\n        if (expirationTimer.unref && process.version !== 'v0.10.34')\n            expirationTimer.unref();\n    }\n\n    /**\n     * Store an item in the cache, using the specified key and value.\n     * Internally will keep track of the time the item was added to the cache\n     * @param id\n     * @param value\n     */\n    save(key: string, value: string, callback: (error: null, value: CacheItem | null) => void){\n        if(!this.cacheKeys[key])\n        {\n            this.cacheKeys[key] = {\n                createdAt: new Date().getTime(),\n                value: value\n            };\n\n            callback(null, this.cacheKeys[key]);\n        }\n        else\n        {\n            callback(null, null);\n        }\n\n    }\n\n\n    /**\n     * Returns the value of the specified key in the cache\n     * @param id\n     * @returns {boolean}\n     */\n    get(key: string, callback: (key: string | null, value: string | null) => void){\n        if(this.cacheKeys[key]){\n            callback(null, this.cacheKeys[key].value);\n        }\n        else\n        {\n            callback(null, null);\n        }\n\n    }\n\n\n    /**\n     * Removes an item from the cache if it exists\n     * @param key\n     */\n    remove(key: string, callback: (err: Error | null, key: string | null) => void){\n        if(this.cacheKeys[key])\n        {\n            delete this.cacheKeys[key];\n            callback(null, key);\n        }\n        else\n        {\n            callback(null, null);\n        }\n\n    }\n}\n"]}